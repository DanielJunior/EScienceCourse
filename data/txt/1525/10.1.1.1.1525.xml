<document id="10.1.1.1.1525"><title src="SVM HeaderParse 0.1">Formal Methods for Industrial Critical Systems (FMICS ’03), vol. 80 of Electronic Notes in Theoretical Computer Science, pp. 73–89, Elsevier, 2003.]</title><abstract src="SVM HeaderParse 0.1">Abstract. The Java Modeling Language (JML) can be used to specify the detailed design of Java classes and interfaces by adding annotations to Java source files. The aim of JML is to provide a specification language that is easy to use for Java programmers and that is supported by a wide range of tools for specification type-checking, runtime debugging, static analysis, and verification. This paper gives an overview of the main ideas behind JML, the different groups collaborating to provide tools for JML, and the existing applications of JML. Thus far, most applications have focused on code for programming smartcards written in the Java Card dialect of Java.</abstract><keywords><keyword id="1249">formal specification</keyword><keyword id="1250">Java</keyword><keyword id="1251">runtime assertion checking</keyword><keyword id="1252">static checking</keyword></keywords><authors><author id="4234"><name src="SVM HeaderParse 0.1">Lilian Burdy</name><address src="SVM HeaderParse 0.1">France</address><order>1</order></author><author id="4235"><name src="SVM HeaderParse 0.1">Yoonsik Cheon</name><order>2</order></author><author id="4236"><name src="SVM HeaderParse 0.1">David Cok</name><order>3</order></author><author id="4237"><name src="SVM HeaderParse 0.1">Michael D. Ernst</name><order>4</order></author><author id="4238"><name src="SVM HeaderParse 0.1">Joe Kiniry</name><order>5</order></author><author id="4239"><name src="SVM HeaderParse 0.1">Gary T. Leavens</name><order>6</order></author><author id="4240"><name src="SVM HeaderParse 0.1">K. Rustan</name><order>7</order></author><author id="4241"><name src="SVM HeaderParse 0.1">M. Leino</name><order>8</order></author><author id="4242"><name src="SVM HeaderParse 0.1">Erik Poll</name><address src="SVM HeaderParse 0.1">USA</address><order>9</order></author></authors><citations src="ParsCit 1.0"><citation id="28664"><authors>J-R Abrial</authors><title>The B-Book: Assigning Programs to Meanings</title><year>1996</year><publisher>Cambridge University Press</publisher><raw>J.-R. Abrial. The B-Book: Assigning Programs to Meanings. Cambridge University Press, 1996.</raw><contexts><context> in order to generate proof obligations from JML-annotated Java sources. Those proof obligations can then be discharged using a theorem prover. Currently the proof obligations are generated for the B [1] method’s prover. The approach taken in JACK is somewhere between those of ESC/Java and LOOP, but probably closer to LOOP than to ESC/Java, trying to get the best of both worlds. On the one hand, JACK</context></contexts></citation><citation id="28665"><authors>Sergio Antoy,Dick Hamlet</authors><title>Automatically checking an implementation against its formal specification</title><venue>IEEE Transactions on Software Engineering</venue><venType>JOURNAL</venType><year>2000</year><volume>26</volume><raw>Sergio Antoy and Dick Hamlet. Automatically checking an implementation against its formal specification. IEEE Transactions on Software Engineering, 26(1):55–69, January 2000. 14 Lilian Burdy et al.</raw><contexts><context>wing Java programmers to use JML specifications as practical and effective tools for debugging, testing, and design by contract. 3.3 Unit testing A formal specification can be viewed as a test oracle [37, 2], and a runtime assertion checker can be used as the decision procedure for the test oracle [11]. This idea has been implemented as a unit testing tool for Java (jmlunit), by combining JML with the po</context></contexts></citation><citation id="28666"><authors>D Bartetzko,C Fischer,M Moller,H Wehrheim</authors><title>Jass — Java with assertions</title><venue>In Workshop on Runtime Verification at CAV’01, 2001. Published in ENTCS, K. Havelund and</venue><venType>CONFERENCE</venType><pages>200--1</pages><editors>G. Rosu (eds</editors><volume>55</volume><raw>D. Bartetzko, C. Fischer, M. Moller, and H. Wehrheim. Jass — Java with assertions. In Workshop on Runtime Verification at CAV’01, 2001. Published in ENTCS, K. Havelund and G. Rosu (eds.), 55(2), 2001.</raw><contexts><context>represents a significant advance over the state of the art in runtime assertion checking as represented by design by contract tools such as Eiffel [33] or by Java tools such as iContract [24] or Jass [3]. The jmlc tool also supports advances such as (stateful) interface specifications, multiple inheritance of specifications, various forms of quantifiers and set comprehension notation, support for str</context></contexts></citation><citation id="28667"><authors>Kent Beck,Erich Gamma</authors><title>Test infected: Programmers love writing tests</title><venue>Java Report</venue><venType>JOURNAL</venType><year>1998</year><volume>3</volume><raw>Kent Beck and Erich Gamma. Test infected: Programmers love writing tests. Java Report, 3(7):37–50, 1998.</raw><contexts><context>e used as the decision procedure for the test oracle [11]. This idea has been implemented as a unit testing tool for Java (jmlunit), by combining JML with the popular unit testing tool JUnit for Java [4]. The jmlunit tool, developed at Iowa State University, frees the programmer from writing most unit test code and significantly automates unit testing of Java classes and interfaces. The tool generate</context></contexts></citation><citation id="28668"><authors>Cees-Bart Breunesse,Joachim van den Berg,Bart Jacobs</authors><title>Specifying and verifying a decimal representation in Java for smart cards</title><venue>AMAST’02, number 2422 in LNCS</venue><venType>CONFERENCE</venType><year>2002</year><pages>304--318</pages><editors>In H. Kirchner and C. Ringeissen, editors</editors><publisher>Springer</publisher><raw>Cees-Bart Breunesse, Joachim van den Berg, and Bart Jacobs. Specifying and verifying a decimal representation in Java for smart cards. In H. Kirchner and C. Ringeissen, editors, AMAST’02, number 2422 in LNCS, pages 304–318. Springer, 2002.</raw><contexts><context>operties than can be handled by extended static checking with ESC/Java. A recent paper describing a case study with the LOOP tool, giving the best impression of the state of the art, is now available [5]. A similar program verification tool for JML-annotated code under development is the Krakatoa tool [31]; it produces proof obligations for the theorem prover Coq, but currently covers only a subset o</context><context>iscussed earlier, which is specifically designed for Java Card programs. One of the classes of the electronic purse mentioned above has provided the most serious case study to date with the LOOP tool [5].s5 Related Work 5.1 Other runtime assertion checkers An Overview of JML Tools and Applications 11 Many runtime assertion checkers for Java exist, for example, Jass, iContract, and Parasoft’s jContrac</context><context>ce the use of JML gradually, simply by adding the odd assertion to some Java code. – JML can be used for existing (legacy) code and APIs. Indeed, most applications of JML and its tools to date (e.g., [5, 8, 39]) have involved existing APIs and code. 3. There is a (growing) availability of a wide range of tool support for JML. Unlike B, JML does not impose a particular design method on its users. Unlike UML,</context></contexts></citation><citation id="28669"><authors>Achim D Brucker,Burkhart Wolff</authors><title>A proposal for a formal OCL semantics in Isabelle/HOL</title><venue>In César Muñoz, Sophiène Tahar, and Víctor Carreño, editors, TPHOL’02, volume 2410 of LNCS</venue><venType>CONFERENCE</venType><year>2002</year><pages>99--114</pages><publisher>Springer</publisher><raw>Achim D. Brucker and Burkhart Wolff. A proposal for a formal OCL semantics in Isabelle/HOL. In César Muñoz, Sophiène Tahar, and Víctor Carreño, editors, TPHOL’02, volume 2410 of LNCS, pages 99–114. Springer, 2002.</raw><contexts><context>the same meaning in JML and Java, as does ==, and the same rules for overriding, overloading, and hiding apply. One cannot expect this for OCL. In fact, a semantics for OCL was only recently proposed [6].s12 Lilian Burdy et al. In all, we believe that a language like JML, which is tailored to Java, is better suited for recording the detailed design of a Java programs than a generic language like OCL.</context></contexts></citation><citation id="28670"><authors>JACK</authors><title>Java Applet Correctness Kit). At http://www.gemplus.com/smart/r d/trends/jack.html</title><year>2002</year><raw>Lilian Burdy, Jean-Louis Lanet, and Antoine Requet. JACK (Java Applet Correctness Kit). At http://www.gemplus.com/smart/r d/trends/jack.html, 2002.</raw><contexts><context>ated code under development is the Krakatoa tool [31]; it produces proof obligations for the theorem prover Coq, but currently covers only a subset of Java. 3.8 Static verification with JACK The JACK [7] tool has been developed at the research lab of Gemplus, a manufacturer of smartcards and smartcard software. JACK aims to provide an environment for Java and Java Card program verification using JML </context></contexts></citation><citation id="28671"><title>Néstor Cataño and Marieke Huisman. Formal specification of Gemplus’s electronic purse case study</title><venue>FME 2002, volume LNCS 2391</venue><venType>CONFERENCE</venType><year>2002</year><pages>272--289</pages><editors>In L. H. Eriksson and P. A. Lindsay, editors</editors><publisher>Springer</publisher><raw>Néstor Cataño and Marieke Huisman. Formal specification of Gemplus’s electronic purse case study. In L. H. Eriksson and P. A. Lindsay, editors, FME 2002, volume LNCS 2391, pages 272–289. Springer, 2002.</raw><contexts><context>used to specify and verify a component of a smartcard operating system [38]. ESC/Java has been used with great success to verify a realistic example of an electronic purse implementation in Java Card [8]. This case study was instrumental in convincing industrial users of the usefulness of JML and feasibility of automated program checking by ESC/Java for Java Card applets. This provided the motivation</context><context>ce the use of JML gradually, simply by adding the odd assertion to some Java code. – JML can be used for existing (legacy) code and APIs. Indeed, most applications of JML and its tools to date (e.g., [5, 8, 39]) have involved existing APIs and code. 3. There is a (growing) availability of a wide range of tool support for JML. Unlike B, JML does not impose a particular design method on its users. Unlike UML,</context></contexts></citation><citation id="28672"><authors>Néstor Cataño,Marieke Huisman</authors><title>CHASE: A static checker for JML’s assignable clause</title><venue>VMCAI: Verification, Model Checking, and Abstract Interpretation, volume 2575 of LNCS</venue><venType>CONFERENCE</venType><year>2003</year><pages>26--40</pages><editors>In Lenore D. Zuck, Paul C. Attie, Agostino Cortesi, and Supratik Mukhopadhyay, editors</editors><publisher>Springer</publisher><raw>Néstor Cataño and Marieke Huisman. CHASE: A static checker for JML’s assignable clause. In Lenore D. Zuck, Paul C. Attie, Agostino Cortesi, and Supratik Mukhopadhyay, editors, VMCAI: Verification, Model Checking, and Abstract Interpretation, volume 2575 of LNCS, pages 26–40. Springer, 2003.</raw><contexts><context> understand. 3.6 CHASE One source of unsoundness of ESC/Java is that it does not check assignable clauses. The semantics of these frame axioms are also not checked by the JML compiler. The CHASE tool [9] tries to remedy these problems. It performs a syntactic check on assignable clauses, which, in the spirit of ESC/Java, is neither sound nor complete, but which spots many mistakes made in assignable </context></contexts></citation><citation id="28673"><authors>Yoonsik Cheon,Gary T Leavens</authors><title>A runtime assertion checker for the Java Modeling Language (JML</title><venue>the International Conference on Software Engineering Research and Practice (SERP ’02</venue><venType>CONFERENCE</venType><year>2002</year><pages>322--328</pages><editors>In Hamid R. Arabnia and Youngsong Mun, editors</editors><publisher>CSREA Press</publisher><raw>Yoonsik Cheon and Gary T. Leavens. A runtime assertion checker for the Java Modeling Language (JML). In Hamid R. Arabnia and Youngsong Mun, editors, the International Conference on Software Engineering Research and Practice (SERP ’02), pages 322–328. CSREA Press, June 2002.</raw><contexts><context>time assertion checking The JML compiler (jmlc), developed at Iowa State University, is an extension to a Java compiler and compiles Java programs annotated with JML specifications into Java bytecode [10]. The compiled bytecode includes runtime assertion checking instructions that check JML specifications such as preconditions, normal and exceptional postconditions, invariants, and history constraints</context></contexts></citation><citation id="28674"><authors>Yoonsik Cheon,Gary T Leavens</authors><title>A simple and practical approach to unit testing: The JML and JUnit</title><venue>ECOOP 2002, volume 2374 of LNCS</venue><venType>CONFERENCE</venType><year>2002</year><pages>231--255</pages><editors>way. In Boris Magnusson, editor</editors><publisher>Springer</publisher><raw>Yoonsik Cheon and Gary T. Leavens. A simple and practical approach to unit testing: The JML and JUnit way. In Boris Magnusson, editor, ECOOP 2002, volume 2374 of LNCS, pages 231–255. Springer, June 2002.</raw><contexts><context>ting, and design by contract. 3.3 Unit testing A formal specification can be viewed as a test oracle [37, 2], and a runtime assertion checker can be used as the decision procedure for the test oracle [11]. This idea has been implemented as a unit testing tool for Java (jmlunit), by combining JML with the popular unit testing tool JUnit for Java [4]. The jmlunit tool, developed at Iowa State University</context><context>s. When the method under test satisfies its precondition, but otherwise has an assertion violation, then the implementation failed to meet its specification, and hence the test data detects a failure [11]. In other words, the generated test code serves as a test oracle whose behavior is derived from the specified behavior of the class being tested. The user is still responsible for generating test dat</context></contexts></citation><citation id="28675"><authors>Yoonsik Cheon,Gary T Leavens,Murali Sitaraman,Stephen Edwards</authors><title>Model variables: Cleanly supporting abstraction in design by contract</title><venType>TECHREPORT</venType><year>2003</year><tech>Technical Report 03-10</tech><raw>Yoonsik Cheon, Gary T. Leavens, Murali Sitaraman, and Stephen Edwards. Model variables: Cleanly supporting abstraction in design by contract. Technical Report 03-10, Department of Computer Science, Iowa State University, April 2003. Available from archives.cs.iastate.edu.</raw><contexts><context>the most important of these below. – To allow specifications to be abstractions of implementation details, JML provides model variables, which play the role of abstract values for abstract data types [12]. For example, if instead of a class Purse, we were specifying an interface PurseInterface, we could introduce the balance as such a model variable. A class implementing this interface could then spec</context></contexts></citation><citation id="28676"><authors>Krishna Kishore Dhara,Gary T Leavens</authors><title>Forcing behavioral subtyping through specification inheritance</title><venue>In 18th International Conference on Software Engineering</venue><venType>CONFERENCE</venType><year>1996</year><pages>258--267</pages><publisher>IEEE Computer Society Press</publisher><raw>Krishna Kishore Dhara and Gary T. Leavens. Forcing behavioral subtyping through specification inheritance. In 18th International Conference on Software Engineering, pages 258–267. IEEE Computer Society Press, 1996.</raw><contexts><context>nces such as (stateful) interface specifications, multiple inheritance of specifications, various forms of quantifiers and set comprehension notation, support for strong and weak behavioral subtyping [30, 13], and a contextual interpretation of undefinedness [27]. In sum, the JML compiler brings “programming benefits” to formal interface specifications by allowing Java programmers to use JML specification</context><context>pecification of object-oriented systems. When exactly should invariants hold? How should concurrency properties be specified? JML’s specification inheritance forces subtypes to be behavioral subtypes [13, 26], but subtyping in Java is used for implementation inheritance as well; is it practical to always weaken the specifications of supertypes enough so that their subtypes are behavioral subtypes? There a</context></contexts></citation><citation id="28677"><authors>Michael D Ernst,Jake Cockrell,William G Griswold,David Notkin</authors><title>Dynamically discovering likely program invariants to support program evolution</title><venue>IEEE Transactions on Software Engineering</venue><venType>JOURNAL</venType><pages>200--1</pages><volume>27</volume><raw>Michael D. Ernst, Jake Cockrell, William G. Griswold, and David Notkin. Dynamically discovering likely program invariants to support program evolution. IEEE Transactions on Software Engineering, 27(2):1–25, 2001.</raw><contexts><context>ls for checking specifications, there are also tools that help a developer write JML specifications, with the aim of reducing the cost of producing JML specifications. • The Daikon tool (Section 3.4, [14]) infers likely invariants by observing the runtime behavior of a program. • The Houdini tool [16] uses ESC/Java to infer annotations for code. • The jmlspec tool can produce a skeleton of a specifica</context><context>on, then verify code against the specification. Writing the JML specification is left to a programmer. Because this task can be time-consuming, tedious, and error-prone, the Daikon invariant detector [14] provides assistance in creating a specification. Daikon outputs observed program properties in JML form and automatically inserts them into a target program. The Daikon tool dynamically detects likel</context></contexts></citation><citation id="28678"><authors>Michael D Ernst,Adam Czeisler,William G Griswold,David Notkin</authors><title>Quickly detecting relevant program invariants</title><venue>In ICSE 2000, Proceedings of the 22nd International Conference on Software Engineering</venue><venType>CONFERENCE</venType><year>2000</year><pages>449--458</pages><raw>Michael D. Ernst, Adam Czeisler, William G. Griswold, and David Notkin. Quickly detecting relevant program invariants. In ICSE 2000, Proceedings of the 22nd International Conference on Software Engineering, pages 449–458, 2000.</raw><contexts><context>re, the actual behavior of the program is not necessarily the same as its intended behavior.) However, Daikon uses static analysis, statistical tests, and other mechanisms to suppress false positives [15]. Even if a property is not true in general, Daikon’s output provides valuable information about the test suite over which the program was run. Even with modest test suites, Daikon’s output is highly </context></contexts></citation><citation id="28679"><authors>Houdini</authors><title>an annotation assistant for esc/java</title><venue>FME 2001, volume LNCS 2021</venue><venType>CONFERENCE</venType><year>2001</year><pages>500--517</pages><editors>In J. N. Oliveira and P. Zave, editors</editors><publisher>Springer</publisher><raw>Cormac Flanagan and K. Rustan M. Leino. Houdini, an annotation assistant for esc/java. In J. N. Oliveira and P. Zave, editors, FME 2001, volume LNCS 2021, pages 500–517. Springer, 2001.</raw><contexts><context>s, with the aim of reducing the cost of producing JML specifications. • The Daikon tool (Section 3.4, [14]) infers likely invariants by observing the runtime behavior of a program. • The Houdini tool [16] uses ESC/Java to infer annotations for code. • The jmlspec tool can produce a skeleton of a specification file from Java source and can compare the interfaces of two different files for consistency. </context></contexts></citation><citation id="28680"><authors>Cormac Flanagan,K Rustan M Leino,Mark Lillibridge,Greg Nelson,James B Saxe</authors><title>Raymie Stata. Extended static checking for Java</title><venue>In ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation (PLDI’2002</venue><venType>CONFERENCE</venType><year>2002</year><pages>234--245</pages><raw>Cormac Flanagan, K. Rustan M. Leino, Mark Lillibridge, Greg Nelson, James B. Saxe, and Raymie Stata. Extended static checking for Java. In ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation (PLDI’2002), pages 234–245, 2002.</raw><contexts><context>tatically checking or verifying JML assertions providing different levels of automation and supporting different levels of expressivity in specifications. • The program checker ESC/Java (Section 3.5) [17] can automatically detect certain common errors in Java code and check relatively simple assertions. • The program checker JACK (Section 3.8) offers a similar functionality to ESC/Java, but is more am</context><context> test suites) performed statistically significantly better on a program verification task than did users who did not have such assistance. 3.5 Extended static checking with ESC/Java The ESC/Java tool [17], developed at Compaq Research, performs what is called “extended static checking”, static checking that goes well beyond type checking. It can check relatively simple assertions and can check for cer</context></contexts></citation><citation id="28681"><authors>Lisa Friendly</authors><title>The design of distributed hyperlinked programming documentation</title><venue>Overview of JML Tools and Applications 15</venue><venType>CONFERENCE</venType><year>1995</year><pages>151--173</pages><editors>In S. Fraïssè, F. Garzotto, T. Isakowitz, J. Nanard, and M. Nanard, editors</editors><publisher>Springer</publisher><volume>95</volume><raw>Lisa Friendly. The design of distributed hyperlinked programming documentation. In S. Fraïssè, F. Garzotto, T. Isakowitz, J. Nanard, and M. Nanard, editors, IWHD’95, pages 151–173. Springer, 1995. An Overview of JML Tools and Applications 15</raw><contexts><context>y, the jmldoc tool (authoreds6 Lilian Burdy et al. by David Cok) produces browsable HTML pages containing both the API and the specifications for Java code, in the style of pages generated by Javadoc [18]. This tool reuses the parsing and checking performed by the JML checker and connects it to the doclet API underlying Javadoc. In this way, jmldoc remains consistent with the definition of JML and cre</context></contexts></citation><citation id="28682"><authors>John V Guttag,James J Horning</authors><title>et al. Larch: Languages and Tools for Formal Specification</title><year>1993</year><publisher>Springer</publisher><pubAddress>New York, NY</pubAddress><raw>John V. Guttag, James J. Horning, et al. Larch: Languages and Tools for Formal Specification. Springer, New York, NY, 1993.</raw><contexts><context>ses some related languages and tools, such as OCL and other runtime assertion checkers, and Section 6 concludes. 2 The JML Notation JML blends Eiffel’s design-by-contract approach [33] with the Larch [19] tradition (and others that space precludes mentioning). Because JML supports quantifiers such as \forall and \exists, and because JML allows “model” (i.e., specification-only) fields, specifications </context></contexts></citation><citation id="28683"><authors>Marieke Huisman</authors><title>Reasoning about Java Programs in higher order logic with PVS and Isabelle. IPA dissertation series</title><year>2001</year><pages>2001--03</pages><pubAddress>Holland</pubAddress><raw>Marieke Huisman. Reasoning about Java Programs in higher order logic with PVS and Isabelle. IPA dissertation series, 2001-03, University of Nijmegen, Holland, February 2001.</raw><contexts><context>ty of a common language; developers can reap the benefits of complementary tools.s3.7 Program verification with LOOP An Overview of JML Tools and Applications 9 The University of Nijmegen’s LOOP tool [23, 20] translates JML-annotated Java code into proof obligations for the theorem prover PVS [36]. One can then try to prove these obligations, interactively, in PVS. The translation from JML to formal proof</context></contexts></citation><citation id="28684"><authors>Bart Jacobs</authors><title>Weakest precondition reasoning for Java programs with JML annotations</title><venue>JLAP</venue><venType>JOURNAL</venType><volume>2002</volume><raw>Bart Jacobs. Weakest precondition reasoning for Java programs with JML annotations. JLAP, 2002. To appear.</raw><contexts><context>d which has been extended to provide a formal semantics for a large part of JML. The verification of the proof obligations is accomplished using a Hoare Logic [22] and a weakest-precondition calculus [21] for Java and JML. Interactive theorem proving is very labor-intensive, but allows verification of more complicated properties than can be handled by extended static checking with ESC/Java. A recent p</context></contexts></citation><citation id="28685"><authors>Bart Jacobs,Erik Poll</authors><title>A logic for the Java Modeling Language JML</title><venue>Fundamental Approaches to Software Engineering (FASE), volume 2029 of LNCS</venue><venType>CONFERENCE</venType><year>2001</year><pages>284--299</pages><editors>In H. Hussmann, editor</editors><publisher>Springer</publisher><raw>Bart Jacobs and Erik Poll. A logic for the Java Modeling Language JML. In H. Hussmann, editor, Fundamental Approaches to Software Engineering (FASE), volume 2029 of LNCS, pages 284–299. Springer, 2001.</raw><contexts><context>a that has has been formalized in PVS, and which has been extended to provide a formal semantics for a large part of JML. The verification of the proof obligations is accomplished using a Hoare Logic [22] and a weakest-precondition calculus [21] for Java and JML. Interactive theorem proving is very labor-intensive, but allows verification of more complicated properties than can be handled by extended </context></contexts></citation><citation id="28686"><authors>Bart Jacobs,Joachim van den Berg,Marieke Huisman,Martijn van Berkum,Ulrich Hensel,Hendrik Tews</authors><title>Reasoning about Java classes (preliminary report</title><venue>In OOPSLA’98, volume 33(10) of ACM SIGPLAN Notices</venue><venType>CONFERENCE</venType><year>1998</year><pages>329--340</pages><publisher>ACM</publisher><raw>Bart Jacobs, Joachim van den Berg, Marieke Huisman, Martijn van Berkum, Ulrich Hensel, and Hendrik Tews. Reasoning about Java classes (preliminary report). In OOPSLA’98, volume 33(10) of ACM SIGPLAN Notices, pages 329–340. ACM, October 1998.</raw><contexts><context>ty of a common language; developers can reap the benefits of complementary tools.s3.7 Program verification with LOOP An Overview of JML Tools and Applications 9 The University of Nijmegen’s LOOP tool [23, 20] translates JML-annotated Java code into proof obligations for the theorem prover PVS [36]. One can then try to prove these obligations, interactively, in PVS. The translation from JML to formal proof</context></contexts></citation><citation id="28687"><authors>Reto Kramer</authors><title>iContract – the Java design by contract tool</title><venue>TOOLS 26: Technology of Object-Oriented Languages and Systems, Los Alamitos, California</venue><venType>CONFERENCE</venType><year>1998</year><pages>295--307</pages><raw>Reto Kramer. iContract – the Java design by contract tool. TOOLS 26: Technology of Object-Oriented Languages and Systems, Los Alamitos, California, pages 295– 307, 1998.</raw><contexts><context>JML compiler represents a significant advance over the state of the art in runtime assertion checking as represented by design by contract tools such as Eiffel [33] or by Java tools such as iContract [24] or Jass [3]. The jmlc tool also supports advances such as (stateful) interface specifications, multiple inheritance of specifications, various forms of quantifiers and set comprehension notation, sup</context></contexts></citation><citation id="28688"><authors>Gary T Leavens,Albert L Baker,Clyde Ruby</authors><title>JML: A notation for detailed design</title><venue>Behavioral Specifications of Businesses and Systems</venue><venType>CONFERENCE</venType><year>1999</year><pages>175--188</pages><editors>In Haim Kilov, Bernhard Rumpe, and Ian Simmonds, editors</editors><publisher>Kluwer Academic Publishers</publisher><pubAddress>Boston</pubAddress><raw>Gary T. Leavens, Albert L. Baker, and Clyde Ruby. JML: A notation for detailed design. In Haim Kilov, Bernhard Rumpe, and Ian Simmonds, editors, Behavioral Specifications of Businesses and Systems, pages 175–188. Kluwer Academic Publishers, Boston, 1999.</raw><contexts><context>amming smartcards written in the Java Card dialect of Java. Keywords. Formal methods, formal specification, Java, runtime assertion checking, static checking, program verification. 1 Introduction JML [25, 26], which stands for “Java Modeling Language”, is useful for specifying detailed designs of Java classes and interfaces. JML is a behavioral interface specification language for Java; that is, it specif</context></contexts></citation><citation id="28689"><authors>Gary T Leavens,Albert L Baker,Clyde Ruby</authors><title>Preliminary design of JML: A behavioral interface specification language for Java</title><venType>TECHREPORT</venType><year>2003</year><tech>Technical Report 9806u</tech><raw>Gary T. Leavens, Albert L. Baker, and Clyde Ruby. Preliminary design of JML: A behavioral interface specification language for Java. Technical Report 9806u, Iowa State University, Department of Computer Science, April 2003. See www.jmlspecs.org.</raw><contexts><context>amming smartcards written in the Java Card dialect of Java. Keywords. Formal methods, formal specification, Java, runtime assertion checking, static checking, program verification. 1 Introduction JML [25, 26], which stands for “Java Modeling Language”, is useful for specifying detailed designs of Java classes and interfaces. JML is a behavioral interface specification language for Java; that is, it specif</context><context> JML uses Java’s expression syntax in assertions, thus JML’s notation is easier for programmers to learn than one based on a language-independent specification language like the Larch Shared Language [26, 27] or OCL [41]. Figure 1 gives an example of a JML specification that illustrates its main features. JML assertions are written as special comments in Java code, either after //@ or between /*@ ... @*/,</context><context>pecification of object-oriented systems. When exactly should invariants hold? How should concurrency properties be specified? JML’s specification inheritance forces subtypes to be behavioral subtypes [13, 26], but subtyping in Java is used for implementation inheritance as well; is it practical to always weaken the specifications of supertypes enough so that their subtypes are behavioral subtypes? There a</context></contexts></citation><citation id="28690"><authors>Gary T Leavens,Yoonsik Cheon,Curtis Clifton,Clyde Ruby,David R Cok</authors><title>How the design of JML accommodates both runtime assertion checking and formal verification</title><venue>Department of Computer Science, Iowa State University</venue><venType>TECHREPORT</venType><year>2003</year><pubAddress>Ames, Iowa, 50011</pubAddress><tech>Technical Report 03-04</tech><raw>Gary T. Leavens, Yoonsik Cheon, Curtis Clifton, Clyde Ruby, and David R. Cok. How the design of JML accommodates both runtime assertion checking and formal verification. Technical Report 03-04, Department of Computer Science, Iowa State University, Ames, Iowa, 50011, March 2003. To appear in the proceedings of FMCO</raw><contexts><context> JML uses Java’s expression syntax in assertions, thus JML’s notation is easier for programmers to learn than one based on a language-independent specification language like the Larch Shared Language [26, 27] or OCL [41]. Figure 1 gives an example of a JML specification that illustrates its main features. JML assertions are written as special comments in Java code, either after //@ or between /*@ ... @*/,</context><context> measures (time and space), the behavior of the original program is unchanged. The transparency of runtime assertion checking is guaranteed, as JML assertions are not allowed to have any side-effects [27]. The JML language provides a rich set of specification facilities to write abstract, complete behavioral specifications of Java program modules [27]. It opens a new possibility in runtime assertion c</context><context>inheritance of specifications, various forms of quantifiers and set comprehension notation, support for strong and weak behavioral subtyping [30, 13], and a contextual interpretation of undefinedness [27]. In sum, the JML compiler brings “programming benefits” to formal interface specifications by allowing Java programmers to use JML specifications as practical and effective tools for debugging, testi</context></contexts></citation><citation id="28691"><authors>K Rustan M Leino,Greg Nelson,James B Saxe</authors><title>ESC/Java user’s manual</title><venue>Technical Note 2000-002, Compaq SRC</venue><venType>CONFERENCE</venType><year>2000</year><raw>K. Rustan M. Leino, Greg Nelson, and James B. Saxe. ESC/Java user’s manual. Technical Note 2000-002, Compaq SRC, October 2000.</raw><contexts><context> potential errors. ESC/Java works by translating a given JML-annotated Java program into verification conditions [29], which are then passed to an automatic theorem prover. The ESC/Java User’s Manual [28] provides a detailed description of the semantics of JML annotations, as they pertain to ESC/Java. As of this writing, there are some small syntactic and semantic differences between JML and the subse</context></contexts></citation><citation id="28692"><authors>K Rustan M Leino,James B Saxe</authors><title>Raymie Stata. Checking Java programs via guarded commands</title><venue>Technical Note 1999-002, Compaq SRC</venue><venType>CONFERENCE</venType><year>1999</year><raw>K. Rustan M. Leino, James B. Saxe, and Raymie Stata. Checking Java programs via guarded commands. Technical Note 1999-002, Compaq SRC, May 1999.</raw><contexts><context>tions, and in turn these annotations help the tool do a better job of checking code for potential errors. ESC/Java works by translating a given JML-annotated Java program into verification conditions [29], which are then passed to an automatic theorem prover. The ESC/Java User’s Manual [28] provides a detailed description of the semantics of JML annotations, as they pertain to ESC/Java. As of this wri</context></contexts></citation><citation id="28693"><authors>Barbara Liskov,Jeannette Wing</authors><title>A behavioral notion of subtyping</title><venue>ACM Transactions on Programming Languages and Systems</venue><venType>JOURNAL</venType><volume>16</volume><raw>Barbara Liskov and Jeannette Wing. A behavioral notion of subtyping. ACM Transactions on Programming Languages and Systems, 16(6):1811–1841, November</raw><contexts><context>nces such as (stateful) interface specifications, multiple inheritance of specifications, various forms of quantifiers and set comprehension notation, support for strong and weak behavioral subtyping [30, 13], and a contextual interpretation of undefinedness [27]. In sum, the JML compiler brings “programming benefits” to formal interface specifications by allowing Java programmers to use JML specification</context></contexts></citation><citation id="28694"><authors>Claude Marché,Christine Paulin,Xavier Urbain</authors><title>The Krakatoa tool for JML/Java program certification. Available at http://krakatoa.lri.fr</title><year>2003</year><raw>Claude Marché, Christine Paulin, and Xavier Urbain. The Krakatoa tool for JML/Java program certification. Available at http://krakatoa.lri.fr, 2003.</raw><contexts><context>e study with the LOOP tool, giving the best impression of the state of the art, is now available [5]. A similar program verification tool for JML-annotated code under development is the Krakatoa tool [31]; it produces proof obligations for the theorem prover Coq, but currently covers only a subset of Java. 3.8 Static verification with JACK The JACK [7] tool has been developed at the research lab of Ge</context></contexts></citation><citation id="28695"><authors>Renaud Marlet,Daniel Le Metayer</authors><title>Security properties and Java Card specificities to be studied in the SecSafe project</title><venType>TECHREPORT</venType><year>2001</year><tech>Technical Report SECSAFE-TL-006, Trusted Logic</tech><raw>Renaud Marlet and Daniel Le Metayer. Security properties and Java Card specificities to be studied in the SecSafe project. Technical Report SECSAFE-TL-006, Trusted Logic, August 2001. Available from http://www.doc.ic.ac.uk/˜siveroni/secsafe/docs.html.</raw><contexts><context>ance, since they are used in sensitive applications such as bank cards and mobile phone SIMs. (An interesting overview of security properties that are relevant for Java Card applications is available [32].) JML, and several tools for JML, have been used for Java Card, especially in the context of the EU-supported project VerifiCard (www.verificard.org). JML has been used to write a formal specificatio</context></contexts></citation><citation id="28696"><authors>Bertrand Meyer</authors><title>Object-oriented Software Construction</title><year>1997</year><publisher>Prentice Hall</publisher><pubAddress>New York, NY</pubAddress><raw>Bertrand Meyer. Object-oriented Software Construction. Prentice Hall, New York, NY, second edition, 1997.</raw><contexts><context>ds. Section 5 discusses some related languages and tools, such as OCL and other runtime assertion checkers, and Section 6 concludes. 2 The JML Notation JML blends Eiffel’s design-by-contract approach [33] with the Larch [19] tradition (and others that space precludes mentioning). Because JML supports quantifiers such as \forall and \exists, and because JML allows “model” (i.e., specification-only) fie</context><context>ost fields, and model methods. Thus the JML compiler represents a significant advance over the state of the art in runtime assertion checking as represented by design by contract tools such as Eiffel [33] or by Java tools such as iContract [24] or Jass [3]. The jmlc tool also supports advances such as (stateful) interface specifications, multiple inheritance of specifications, various forms of quantif</context></contexts></citation><citation id="28697"><authors>Jeremy W Nimmer,Michael D Ernst</authors><title>Automatic generation of program specifications</title><venue>In ISSTA 2002, International Symposium on Software Testing and Analysis</venue><venType>CONFERENCE</venType><year>2002</year><pages>232--242</pages><pubAddress>Rome, Italy</pubAddress><raw>Jeremy W. Nimmer and Michael D. Ernst. Automatic generation of program specifications. In ISSTA 2002, International Symposium on Software Testing and Analysis, pages 232–242, Rome, Italy, 2002.</raw><contexts><context>general, Daikon’s output provides valuable information about the test suite over which the program was run. Even with modest test suites, Daikon’s output is highly accurate. In one set of experiments [34], over 90% of the properties that it reported were verifiable by ESC/Java (the other properties were true, but were beyond the capabilities of ESC/Java), and it reported over 90% of the properties tha</context></contexts></citation><citation id="28698"><authors>Jeremy W Nimmer,Michael D Ernst</authors><title>Invariant inference for static checking: An empirical evaluation</title><venue>In ACM SIGSOFT 10th International Symposium on the Foundations of Software Engineering (FSE 2002</venue><venType>CONFERENCE</venType><year>2002</year><pages>11--20</pages><raw>Jeremy W. Nimmer and Michael D. Ernst. Invariant inference for static checking: An empirical evaluation. In ACM SIGSOFT 10th International Symposium on the Foundations of Software Engineering (FSE 2002), pages 11–20, 2002. 16 Lilian Burdy et al.</raw><contexts><context>r example, if Daikon generated 100 properties, users had only to delete less than 10 properties and to add another 10 properties in order to have a verifiable set of properties. In another experiment [35],s8 Lilian Burdy et al. users who were provided with Daikon output (even from unrealistically bad test suites) performed statistically significantly better on a program verification task than did user</context></contexts></citation><citation id="28699"><authors>S Owre,S Rajan,J M Rushby,N Shankar,M Srivas</authors><title>PVS: Combining specification, proof checking, and model checking</title><venue>Computer Aided Verification, number 1102 in LNCS</venue><venType>CONFERENCE</venType><pages>411--414</pages><editors>In R. Alur and T.A. Henzinger, editors</editors><publisher>Springer</publisher><raw>S. Owre, S. Rajan, J.M. Rushby, N. Shankar, and M. Srivas. PVS: Combining specification, proof checking, and model checking. In R. Alur and T.A. Henzinger, editors, Computer Aided Verification, number 1102 in LNCS, pages 411–414. Springer,</raw><contexts><context>verification with LOOP An Overview of JML Tools and Applications 9 The University of Nijmegen’s LOOP tool [23, 20] translates JML-annotated Java code into proof obligations for the theorem prover PVS [36]. One can then try to prove these obligations, interactively, in PVS. The translation from JML to formal proof obligations builds on a formal semantics for sequential Java that has has been formalized</context></contexts></citation><citation id="28700"><authors>Dennis K Peters,David Lorge</authors><title>Parnas. Using test oracles generated from program documentation</title><venue>IEEE Transactions on Software Engineering</venue><venType>JOURNAL</venType><volume>24</volume><raw>Dennis K. Peters and David Lorge Parnas. Using test oracles generated from program documentation. IEEE Transactions on Software Engineering, 24(3):161–173,</raw><contexts><context>wing Java programmers to use JML specifications as practical and effective tools for debugging, testing, and design by contract. 3.3 Unit testing A formal specification can be viewed as a test oracle [37, 2], and a runtime assertion checker can be used as the decision procedure for the test oracle [11]. This idea has been implemented as a unit testing tool for Java (jmlunit), by combining JML with the po</context></contexts></citation><citation id="28701"><authors>Erik Poll,Pieter Hartel,Eduard de Jong</authors><title>A Java reference model of transacted memory for smart cards</title><venue>In Smart Card Research and Advanced Application Conference (CARDIS’2002</venue><venType>CONFERENCE</venType><year>2002</year><pages>75--86</pages><pubAddress>USENIX</pubAddress><raw>Erik Poll, Pieter Hartel, and Eduard de Jong. A Java reference model of transacted memory for smart cards. In Smart Card Research and Advanced Application Conference (CARDIS’2002), pages 75–86. USENIX, 2002.</raw><contexts><context>experience has shown that JML is expressive enough to specify a non-trivial existing API. The runtime assertion checker has been used to specify and verify a component of a smartcard operating system [38]. ESC/Java has been used with great success to verify a realistic example of an electronic purse implementation in Java Card [8]. This case study was instrumental in convincing industrial users of the</context></contexts></citation><citation id="28702"><authors>Jim Rumbaugh,Ivar Jacobson,Grady Booch</authors><title>The Unified Modeling Language Reference Manual</title><year>1998</year><publisher>Addison-Wesley Publishing Company</publisher><raw>Jim Rumbaugh, Ivar Jacobson, and Grady Booch. The Unified Modeling Language Reference Manual. Addison-Wesley Publishing Company, 1998.</raw><contexts><context>on. The developers of Jass have expressed interest in moving to JML as their specification language. 5.2 JML vs. OCL Despite the similarity in the acronyms, JML is very different in its aims from UML [40]. Unlike UML, which attempts to have notations for all phases of the analysis and design process, JML has the much more modest aim of describing the behavior of Java classes and interfaces and recordi</context></contexts></citation><citation id="28703"><authors>Jos Warmer,Anneke Kleppe</authors><title>The Object Constraint Language: Precise Modeling with UML</title><year>1999</year><publisher>Addison-Wesley Publishing Company</publisher><raw>Jos Warmer and Anneke Kleppe. The Object Constraint Language: Precise Modeling with UML. Addison-Wesley Publishing Company, 1999.</raw><contexts><context> expression syntax in assertions, thus JML’s notation is easier for programmers to learn than one based on a language-independent specification language like the Larch Shared Language [26, 27] or OCL [41]. Figure 1 gives an example of a JML specification that illustrates its main features. JML assertions are written as special comments in Java code, either after //@ or between /*@ ... @*/, so that the</context></contexts></citation></citations><fileInfo><url>http://www.gemplus.com/smart/r_d/publications/pdf/BCC_03jm.pdf</url><repID>rep1</repID><conversionTrace>PDFLib TET</conversionTrace><checkSums><checkSum><fileType>pdf</fileType><sha1>d525d0c88e36d0c9edf91cc8ee11d758a0f0aebf</sha1></checkSum></checkSums></fileInfo></document>