<document id="10.1.1.1.1606"><title src="SVM HeaderParse 0.1">Issues in the Practical Use of Graph Rewriting</title><abstract src="SVM HeaderParse 0.1">Abstract. Graphs are a popular data structure, and graph-manipulation programs are common. Graph manipulations can be cleanly, compactly, and explicitly described using graph-rewriting notation. However, when a software developer is persuaded to try graph rewriting, several problems commonly arise. Primarily, it is difficult for a newcomer to develop a feel for how computations are expressed via graph rewriting. Also, graph-rewriting is not convenient for solving all aspects of a problem: better mechanisms are needed for interfacing graph rewriting with other styles of computation. Efficiency considerations and the limited availability of development tools further limit practical use of graph rewriting. The inaccessible appearance of the graph-rewriting literature is an additional hindrance. These problems can be addressed through a combination of “public relations ” work, and further research and development, thereby promoting the widespread use of graph rewriting. 1.</abstract><keywords></keywords><authors><author id="4461"><name src="SVM HeaderParse 0.1">Dorothea Blostein</name><address src="SVM HeaderParse 0.1">Canada K7L 3N6</address><email src="SVM HeaderParse 0.1">blostein@qucis.queensu.ca</email><order>1</order></author><author id="4462"><name src="SVM HeaderParse 0.1">Hoda Fahmy</name><address src="SVM HeaderParse 0.1">Canada K7L 3N6</address><order>2</order></author><author id="4463"><name src="SVM HeaderParse 0.1">Ann Grbavec</name><address src="SVM HeaderParse 0.1">Canada K7L 3N6</address><order>3</order></author></authors><citations src="ParsCit 1.0"><citation id="30098"><authors>R Anderson</authors><venue>Two Dimensional Mathematical Notation,” in Syntactic Pattern Recognition, Applications</venue><venType>CONFERENCE</venType><year>1977</year><pages>147--177</pages><editors>K. S. Fu editor</editors><publisher>Springer</publisher><raw>R. Anderson, “Two Dimensional Mathematical Notation,” in Syntactic Pattern Recognition, Applications, K. S. Fu editor, Springer 1977, pp. 147-177.</raw><contexts><context>cular parser, the developer is usually aware of the order in which the parser tries alternatives. The developer may make use of this to design a smaller or faster graph grammar. For example, Anderson [Ande77] uses a set-based “coordinate grammar” to recognize mathematical notation. He describes his reliance on production-rule ordering to distinguish an input “cos” as a word denoting a trigonometric functi</context></contexts></citation><citation id="30099"><authors>O Arnold,K Jantke</authors><title>Therapy Plans as Hierarchically Structured Graphs</title><raw>O. Arnold and K. Jantke, “Therapy Plans as Hierarchically Structured Graphs,” in</raw><contexts><context>tructure with hierarchy-expressing rewriting rules used to zoom in and out [EhHK92] and to manage and display a derivation [Hims94]; use of hierarchical graphs in a formal approach to plan generation [ArJa94]; use of hierarchically distributed graph transformations [Taen94]. 2' A A 1' 3' B C B C Cs15 11. Mr. Maggraphen: A lot of our C code performs graph inspections. How can we translate this into graph-r</context></contexts></citation><citation id="30100"><authors>D Blostein,H Fahmy,A Grbavec</authors><title>Practical Use of Graph Rewriting</title><venType>TECHREPORT</venType><year>1995</year><tech>Technical Report No. 95-373</tech><raw>, pp. 338-343.[BlFG95] D. Blostein, H. Fahmy, A. Grbavec, “Practical Use of Graph Rewriting,” Technical Report No. 95-373, Computing and Information Science, Queen’s University, Jan 1995.</raw></citation><citation id="30101"><authors>H Bunke</authors><title>Attributed Programmed Graph Grammars and Their Application to Schematic Diagram Interpretation</title><venue>IEEE Pattern Analysis and Machine Intelligence</venue><venType>JOURNAL</venType><year>1982</year><pages>574--582</pages><volume>4</volume><raw>H. Bunke, “Attributed Programmed Graph Grammars and Their Application to Schematic Diagram Interpretation,” IEEE Pattern Analysis and Machine Intelligence, Vol. 4, No. 6, Nov. 1982, pp. 574-582.</raw><contexts><context>h rewriting may be used. (Relevant references, discussed in [BlFG95], include: software engineering [EnLS87] [ELNSS92] [LoKa92] [Pfei90], syntactic pattern recognition [Fu82], document image analysis [Bunk82a] [FaBl93] [GrBl95] [CoTV93], 3D object recognition [LiFu86], visual programming environments [EgPM92], diagram editors [Gött92] [DoTo88], databases [EhKr80], and semantic networks [EhHK92]. Further di</context><context>cable rules. In contrast, an ordered graph rewriting system can directly transform an input graph into an output graph, with a limited number of production rules under consideration at any given time [Bunk82a]. Event-driven graph-rewriting systems can be highly time-efficient, applying rules only in direct response to external actions. Thus, if an application is such that it can bes5 System Components Syst</context><context> many computations it is convenient to order, or partially order, a collection of rewrite rules. For example, Bunke recognizes circuit diagrams by first applying a collection of noise-reduction rules [Bunk82a]. It is critical that these noise-reduction rules be applied first, and exhaustively, before application of rules for recognition of transistors, capacitors, and so on. Similarly, a recognition approa</context><context>se to an editing command (e.g. [Gött92]). • Partially ordered rewrite systems, without backtracking, have been used for software engineering (e.g. [ELNSS92]) and diagram recognition (circuit-diagrams [Bunk82a], music-notation [FaBl93] [Fahm95], math-notation [GrBl95]). In the diagram recognition work, the control specification orders the phases that make up the recognition process; rules within a phase are</context><context>r unsuccessful application of the production. This can be specified in tabular form [Fu82], which quickly becomes difficult to read. Diagrammatic control specifications (control diagrams) are used by [Bunk82a], with extensions by [DoTo88] [FaBl93] and others. For example, a block condition allows the control diagram to test attribute values of any nodes involved in the most recent production [DoTo88]. To p</context></contexts></citation><citation id="30102"><authors>H Bunke</authors><title>On the Generative Power of Sequential and Parallel Programmed Graph</title><venue>Grammars,” Computing</venue><venType>JOURNAL</venType><year>1982</year><pages>89--112</pages><volume>29</volume><raw>H. Bunke, “On the Generative Power of Sequential and Parallel Programmed Graph Grammars,” Computing, Vol. 29, 1982, pp. 89-112.</raw></citation><citation id="30103"><authors>H Bunke,T Glauser,T Tran</authors><title>An Efficient Implementation of</title><venue>Graph Grammars Based on the RETE Matching Algorithm,” in [IWGG91</venue><venType>CONFERENCE</venType><pages>174--189</pages><raw>H. Bunke, T. Glauser, T. Tran, “An Efficient Implementation of Graph Grammars Based on the RETE Matching Algorithm,” in [IWGG91], pp. 174-189.</raw><contexts><context>on conditions; these can be exploited to greatly reduce the search space for isomorphic subgraphs that meet the application condition. The optimization of subgraph-isomorphism testing is discussed in [BuGT91] [Zünd94]. Of course, graph rewriting should not be marketed as a fast style of computation: the von Neumann architecture (geared toward instruction fetch and execution, with a bottleneck between proc</context></contexts></citation><citation id="30104"><authors>H Bunke,B Haller</authors><title>Syntactic Analysis of Context-Free Plex Languages for Pattern Recognition</title><venue>in Structured Document Image Analysis</venue><venType>CONFERENCE</venType><year>1992</year><pages>500--519</pages><publisher>Springer</publisher><pubAddress>Eds. Baird, Bunke, Yamamoto</pubAddress><raw>H. Bunke and B. Haller, “Syntactic Analysis of Context-Free Plex Languages for Pattern Recognition,” in Structured Document Image Analysis, Eds. Baird, Bunke, Yamamoto, Springer 1992, pp. 500-519.</raw><contexts><context>ws. Kaul presents a linear-time precedence parser for a special class of context free graph-grammars [Kaul83]. Bunke and Haller describe an extension of Early’s parser for context-free plex languages [BuHa92]; this parser permits left-recursion and is capable of recognizing partial structures. Recently, a parsing algorithm applicable to context-sensitive graph grammars has been developed [ReSc94]. Egar et</context></contexts></citation><citation id="30105"><authors>S Collin,K Tombre,P Vaxiviere</authors><title>Don’t Tell Mom I’m Doing Document Analysis</title><venue>She Believes I’m in the Computer Vision Field,” Proc. Second Intl. Conf. on Document Analysis and Recognition</venue><venType>CONFERENCE</venType><year>1993</year><pages>619--622</pages><pubAddress>Tsukuba, Japan</pubAddress><raw>S. Collin, K. Tombre, P. Vaxiviere, “Don’t Tell Mom I’m Doing Document Analysis; She Believes I’m in the Computer Vision Field,” Proc. Second Intl. Conf. on Document Analysis and Recognition, Tsukuba, Japan, Oct. 1993, pp. 619-622.</raw><contexts><context>levant references, discussed in [BlFG95], include: software engineering [EnLS87] [ELNSS92] [LoKa92] [Pfei90], syntactic pattern recognition [Fu82], document image analysis [Bunk82a] [FaBl93] [GrBl95] [CoTV93], 3D object recognition [LiFu86], visual programming environments [EgPM92], diagram editors [Gött92] [DoTo88], databases [EhKr80], and semantic networks [EhHK92]. Further discussion is given by [Panel</context><context>anticdirected top-down backtrack parser for plex grammars [LiFu86]. Collin et al. interpret dimensions in engineering drawings using a plex-grammar parser that mixes top-down and bottom-up processing [CoTV93]. A chart-based parser for hierarchical graphs is discussed in [MaKl92]. More recently, Klauck reports on a heuristically-driven chart parser and it’s application to CAD/CAM [Klau94]. On a related not</context></contexts></citation><citation id="30106"><authors>J Dolado,F Torrealdea</authors><title>Formal Manipulation of Forrester Diagrams by Graph Grammars</title><venue>IEEE Trans. Systems, Man and Cybernetics</venue><venType>JOURNAL</venType><year>1988</year><pages>981--996</pages><volume>18</volume><raw>J. Dolado, F. Torrealdea, “Formal Manipulation of Forrester Diagrams by Graph Grammars,” IEEE Trans. Systems, Man and Cybernetics 18(6), pp. 981-996, Nov 1988.</raw><contexts><context> syntactic pattern recognition [Fu82], document image analysis [Bunk82a] [FaBl93] [GrBl95] [CoTV93], 3D object recognition [LiFu86], visual programming environments [EgPM92], diagram editors [Gött92] [DoTo88], databases [EhKr80], and semantic networks [EhHK92]. Further discussion is given by [Panel91].) The fostering of a graph-rewriting culture will go far toward the popularization of graph rewriting. 3.</context><context>the production. This can be specified in tabular form [Fu82], which quickly becomes difficult to read. Diagrammatic control specifications (control diagrams) are used by [Bunk82a], with extensions by [DoTo88] [FaBl93] and others. For example, a block condition allows the control diagram to test attribute values of any nodes involved in the most recent production [DoTo88]. To permit more flexible control c</context><context>uthors mention an anticipated need for control structures within a single transaction. Ordered graph rewriting can be used to regulate event-driven graph rewriting. In the Forrester-diagram editor of [DoTo88], the control specification defines which editing events are legal at any given point. Events not foreseen by the control specification are disallowed, resulting in an error message to the user. A sim</context><context>of [EhKr80]. Using rewrite rules with formally-characterized properties, graph rewriting can provide a formal definition of graph classes; examples include the class of well-formed Forrester diagrams [DoTo88] and the class of well-formed semantic networks [EhHK92]. Readability and Intellectual Manageability Readability of rewrite rules affects intellectual manageability, system development time, ease of m</context></contexts></citation><citation id="30107"><authors>J Egar,A Puerta,M Musen</authors><title>Automated Interpretation of Diagrams for Specification of</title><venue>Stanford University</venue><venType>CONFERENCE</venType><year>1992</year><pages>189--192</pages><raw>J. Egar, A. Puerta, M. Musen, “Automated Interpretation of Diagrams for Specification of Medical Protocols,” AAAI Symposium: Reasoning with Diagrammatic Representations, Stanford University, March 1992, p 189-192.</raw><contexts><context>nLS87] [ELNSS92] [LoKa92] [Pfei90], syntactic pattern recognition [Fu82], document image analysis [Bunk82a] [FaBl93] [GrBl95] [CoTV93], 3D object recognition [LiFu86], visual programming environments [EgPM92], diagram editors [Gött92] [DoTo88], databases [EhKr80], and semantic networks [EhHK92]. Further discussion is given by [Panel91].) The fostering of a graph-rewriting culture will go far toward the po</context><context>g algorithm applicable to context-sensitive graph grammars has been developed [ReSc94]. Egar et al. use a graph-grammar parser in the design of a visual programming environment for clinical protocols [EgPM92]. Lin and Fu recognize three-dimensional objects (in two-dimensional images) using a semanticdirected top-down backtrack parser for plex grammars [LiFu86]. Collin et al. interpret dimensions in engine</context></contexts></citation><citation id="30108"><authors>H Ehrig,H Kreowski</authors><title>Applications of Graph Grammar Theory to Consistency, Synchronization, and Scheduling</title><venue>in Data Base Systems,” Information Systems</venue><venType>CONFERENCE</venType><year>1980</year><pages>225--238</pages><volume>5</volume><raw>H. Ehrig and H. Kreowski, “Applications of Graph Grammar Theory to Consistency, Synchronization, and Scheduling in Data Base Systems,” Information Systems, Vol. 5, pp. 225-238, 1980.</raw><contexts><context>ecognition [Fu82], document image analysis [Bunk82a] [FaBl93] [GrBl95] [CoTV93], 3D object recognition [LiFu86], visual programming environments [EgPM92], diagram editors [Gött92] [DoTo88], databases [EhKr80], and semantic networks [EhHK92]. Further discussion is given by [Panel91].) The fostering of a graph-rewriting culture will go far toward the popularization of graph rewriting. 3. Mr. Maggraphen: In </context><context> ordering of the rewrite rules, event-driven systems have an externally-imposed ordering, arising from the ordering of external events. This is illustrated by the library system of Ehrig and Kreowski [EhKr80]. An external event, such as loaning, returning, or ordering a library book, results in the invocation of a corresponding rewrite rule. Parameters provide the rewrite rule with information describing </context><context>an offer significant advantages. For example, algebraic graph rewriting simplifies construction of proofs about the integrity of a database system, as illustrated by the library-transaction system of [EhKr80]. Using rewrite rules with formally-characterized properties, graph rewriting can provide a formal definition of graph classes; examples include the class of well-formed Forrester diagrams [DoTo88] an</context></contexts></citation><citation id="30109"><authors>H Ehrig,A Habel,H Kreowski</authors><title>Introduction to Graph Grammars with Applications to Semantic Networks</title><venue>International Journal of Computers and Mathematical Applications</venue><venType>JOURNAL</venType><year>1992</year><pages>6--9</pages><volume>23</volume><raw>H. Ehrig, A. Habel, H. Kreowski, “Introduction to Graph Grammars with Applications to Semantic Networks,” International Journal of Computers and Mathematical Applications, Vol. 23, No 6-9, pp. 557-572, 1992.</raw><contexts><context>e analysis [Bunk82a] [FaBl93] [GrBl95] [CoTV93], 3D object recognition [LiFu86], visual programming environments [EgPM92], diagram editors [Gött92] [DoTo88], databases [EhKr80], and semantic networks [EhHK92]. Further discussion is given by [Panel91].) The fostering of a graph-rewriting culture will go far toward the popularization of graph rewriting. 3. Mr. Maggraphen: In C, we use standard algorithms (s</context><context>on the A-labeled node. A set of rewrite rules is used to enumerate each possible configuration of incident edges. (The “...” notation, denoting variable repetition of nodes and edges, is adapted from [EhHK92]. Similarly, Δ−notation uses *-groups, which denote zero or more occurrences of starred graph elements, to implement node-deletion [KaLG91, p. 478]. A Δ-rule that deletes a node is syntactic shorthand</context><context>ized properties, graph rewriting can provide a formal definition of graph classes; examples include the class of well-formed Forrester diagrams [DoTo88] and the class of well-formed semantic networks [EhHK92]. Readability and Intellectual Manageability Readability of rewrite rules affects intellectual manageability, system development time, ease of maintenance, and ease of debugging. It can be particularl</context><context> and are easily perceived from visually-corresponding nodes in g l and g r (Figure 5). Similarly, gluing isomorphisms are effectively conveyed by the visual correspondence of g l and g r nodes, as in [EhHK92]. • Embeddings that are more complex than the elementary type (e.g., they involve testing of node-labels in RestGraph, or following of edges in RestGraph) are easier to perceive if a diagrammatic nota</context><context>ototype algebraic-rewrite environment [LöBe93]; graphs where node labels can be graphs themselves [Schn93]; flat host-graph structure with hierarchy-expressing rewriting rules used to zoom in and out [EhHK92] and to manage and display a derivation [Hims94]; use of hierarchical graphs in a formal approach to plan generation [ArJa94]; use of hierarchically distributed graph transformations [Taen94]. 2' A A </context></contexts></citation><citation id="30110"><authors>H Ehrig,G Engels</authors><title>Pragmatic and Semantic Aspects of a Module Concept for Graph Transformation Systems</title><venue>in [IWGG94</venue><venType>CONFERENCE</venType><pages>157--168</pages><raw>H. Ehrig and G. Engels, “Pragmatic and Semantic Aspects of a Module Concept for Graph Transformation Systems,” in [IWGG94], pp. 157-168.</raw></citation><citation id="30111"><authors>G Engels,C Lewerentz,W Schafer</authors><title>Graph Grammar Engineering: A Software Specification Method</title><venue>in [IWGG87</venue><venType>CONFERENCE</venType><pages>186--201</pages><raw>G. Engels, C. Lewerentz, W. Schafer, “Graph Grammar Engineering: A Software Specification Method,” in [IWGG87], pp. 186-201.</raw><contexts><context>te, executable systems are most helpful. These illustrate various computational styles in which graph rewriting may be used. (Relevant references, discussed in [BlFG95], include: software engineering [EnLS87] [ELNSS92] [LoKa92] [Pfei90], syntactic pattern recognition [Fu82], document image analysis [Bunk82a] [FaBl93] [GrBl95] [CoTV93], 3D object recognition [LiFu86], visual programming environments [EgPM9</context></contexts></citation><citation id="30112"><authors>G Engels,C Lewerentz,M Nagl,W Schafer,A Schürr</authors><title>Building Integrated Software Development Environments Part 1: Tool Specification</title><venue>ACM Trans. Software Engineering and Methodology</venue><venType>JOURNAL</venType><year>1992</year><pages>135--167</pages><volume>1</volume><raw>G. Engels, C. Lewerentz, M. Nagl, W. Schafer, A. Schürr, “Building Integrated Software Development Environments Part 1: Tool Specification,” ACM Trans. Software Engineering and Methodology, Vol. 1, No. 2, Apr. 1992, pp. 135-167.</raw><contexts><context>table systems are most helpful. These illustrate various computational styles in which graph rewriting may be used. (Relevant references, discussed in [BlFG95], include: software engineering [EnLS87] [ELNSS92] [LoKa92] [Pfei90], syntactic pattern recognition [Fu82], document image analysis [Bunk82a] [FaBl93] [GrBl95] [CoTV93], 3D object recognition [LiFu86], visual programming environments [EgPM92], diagra</context><context>hm design or analysis. We have few libraries of standard graph-rewriting code. (An inspiring example is given by the parameterized graphrewrite rules for abstract-syntax-tree manipulation reported in [ELNSS92]). We need to develop specialized algorithm design techniques, geared toward graph rewriting as the primitive operation. Precedents for such specialized algorithm design techniques include VLSI design</context><context>er development. The remaining environments may become available for general use. Our apologies if this list is incomplete. - PROGRES provides extensive facilities for ordered graph rewriting [NaSc91] [ELNSS92]. Contact andy@i3.informatik.rwth-aachen.de to obtain this software.s4 - GraphEd [Hims91] provides extensive graph-display capabilities, and supports a limited form of graph-rewriting (direct-derivati</context><context>sistent edges, and Incorporate prunes the graphs7 while adding semantic information to attributes). Graph applications in software engineering have made extensive use of ordered graph rewriting (e.g. [ELNSS92]). Various forms of ordered graph rewriting are possible, depending on the use of nondeterminism and backtracking: • A completely deterministic system results from pairing a deterministic control spec</context><context>ations, where end-users expect a deterministic response to an editing command (e.g. [Gött92]). • Partially ordered rewrite systems, without backtracking, have been used for software engineering (e.g. [ELNSS92]) and diagram recognition (circuit-diagrams [Bunk82a], music-notation [FaBl93] [Fahm95], math-notation [GrBl95]). In the diagram recognition work, the control specification orders the phases that make</context></contexts></citation><citation id="30113"><authors>H Fahmy,D Blostein</authors><title>A Graph Grammar Programming Style for Recognition of Music Notation</title><venue>Machine Vision and Applications, Vol 6, No 2</venue><venType>CONFERENCE</venType><year>1993</year><pages>83--99</pages><raw>H. Fahmy and D. Blostein, “A Graph Grammar Programming Style for Recognition of Music Notation,” Machine Vision and Applications, Vol 6, No 2, pp. 83-99, 1993.</raw><contexts><context>ction. This can be specified in tabular form [Fu82], which quickly becomes difficult to read. Diagrammatic control specifications (control diagrams) are used by [Bunk82a], with extensions by [DoTo88] [FaBl93] and others. For example, a block condition allows the control diagram to test attribute values of any nodes involved in the most recent production [DoTo88]. To permit more flexible control constructs</context><context>sactions and subdiagrams as encapsulation tools [ZüSc92]. Ordering can be used to structure the computation into phases; for example, Build-Constrain-(Rank)-Incorporate recognition stages are used in [FaBl93] [GrBl95]. Two-level rewrite rules Generic graph-rewrite rules (expressed as graphs) can be transformed via meta-rules, to produce executable rewrite rules. This has been used in a system to describe </context><context>ss difficult for an outsider to learn how to use graph rewriting in a practical application. The Maggraphens’ experience mirrors our own: as we set out to apply graph rewriting to diagram recognition [FaBl93] [GrBl95] [Fahm95], we found it hard to figure out how to organize our computation. A careful reading of the literature was only of limited help: we found extensive discussion of graphrewriting mechan</context></contexts></citation><citation id="30114"><authors>H Fahmy</authors><title>Reasoning in the Presence of Uncertainty via Graph Rewriting</title><venue>Ph.D. Thesis, Computing and Information Science, Queen’s University, March1995</venue><venType>CONFERENCE</venType><raw>H. Fahmy, “Reasoning in the Presence of Uncertainty via Graph Rewriting,” Ph.D. Thesis, Computing and Information Science, Queen’s University, March1995.</raw><contexts><context>t92]). • Partially ordered rewrite systems, without backtracking, have been used for software engineering (e.g. [ELNSS92]) and diagram recognition (circuit-diagrams [Bunk82a], music-notation [FaBl93] [Fahm95], math-notation [GrBl95]). In the diagram recognition work, the control specification orders the phases that make up the recognition process; rules within a phase are unordered or partially ordered, a</context><context>n outsider to learn how to use graph rewriting in a practical application. The Maggraphens’ experience mirrors our own: as we set out to apply graph rewriting to diagram recognition [FaBl93] [GrBl95] [Fahm95], we found it hard to figure out how to organize our computation. A careful reading of the literature was only of limited help: we found extensive discussion of graphrewriting mechanisms, but little d</context></contexts></citation><citation id="30115"><authors>K S Fu</authors><venue>Syntactic Pattern Recognition and Applications</venue><venType>CONFERENCE</venType><year>1982</year><publisher>Prentice Hall</publisher><raw>K. S. Fu, Syntactic Pattern Recognition and Applications, Prentice Hall 1982.</raw><contexts><context>mputational styles in which graph rewriting may be used. (Relevant references, discussed in [BlFG95], include: software engineering [EnLS87] [ELNSS92] [LoKa92] [Pfei90], syntactic pattern recognition [Fu82], document image analysis [Bunk82a] [FaBl93] [GrBl95] [CoTV93], 3D object recognition [LiFu86], visual programming environments [EgPM92], diagram editors [Gött92] [DoTo88], databases [EhKr80], and sem</context><context>tion(s) to try after successful application of the current production. The failure set lists productions to try after unsuccessful application of the production. This can be specified in tabular form [Fu82], which quickly becomes difficult to read. Diagrammatic control specifications (control diagrams) are used by [Bunk82a], with extensions by [DoTo88] [FaBl93] and others. For example, a block condition</context></contexts></citation><citation id="30116"><authors>H Göttler</authors><title>Attribute Graph Grammars for Graphics</title><venue>in [IWGG83</venue><venType>CONFERENCE</venType><pages>130--142</pages><raw>H. Göttler, “Attribute Graph Grammars for Graphics,” in [IWGG83], pp. 130-142.</raw><contexts><context>g r (to be added) unique part of g l (the &amp;quot;retraction&amp;quot;) Application Condition (the &amp;quot;guard&amp;quot;) Required Context Prohibited Context (the &amp;quot;restriction&amp;quot;) unique part of g r (the &amp;quot;insertion&amp;quot;) (a) Y notation [Gött83] (b) X notation [Gött92] (c) Δ notation [LoKa92] Figure 3 Three diagrammatic notations for graph-rewrite rules. In Y and X notations, the embedding is shown as optional context: these diagrammatic dep</context></contexts></citation><citation id="30117"><authors>H Göttler,J Gunther,G Nieskens</authors><title>Use Graph Grammars to Design CADSystems</title><venue>in [IWGG91</venue><venType>CONFERENCE</venType><pages>396--410</pages><raw>H. Göttler, J. Gunther, G. Nieskens, “Use Graph Grammars to Design CADSystems!” in [IWGG91], pp. 396-410.</raw></citation><citation id="30118"><authors>H Göttler</authors><title>Diagram Editors = Graphs + Attributes + Graph Grammars,” International Journal of Man-Machine Studies, Vol 37, No 4</title><venue>in ObjectOriented Databases by Two-level Graph Productions,” in [IWGG94], pp. 151156.[GrBl95] A. Grbavec and D. Blostein, “Mathematics Recognition Using Graph Rewriting,” Third International Conference on Document Analysis and Recognition</venue><venType>CONFERENCE</venType><year>1992</year><pages>481502--94</pages><pubAddress>Montreal, Canada</pubAddress><raw>H. Göttler, “Diagram Editors = Graphs + Attributes + Graph Grammars,” International Journal of Man-Machine Studies, Vol 37, No 4, Oct. 1992, pp. 481502.[GöHi94] H. Göttler and B. Himmelreich, “Modeling of Transactions in ObjectOriented Databases by Two-level Graph Productions,” in [IWGG94], pp. 151156.[GrBl95] A. Grbavec and D. Blostein, “Mathematics Recognition Using Graph Rewriting,” Third International Conference on Document Analysis and Recognition, Montreal, Canada, August 1995, pp. 417-421.</raw><contexts><context>[Pfei90], syntactic pattern recognition [Fu82], document image analysis [Bunk82a] [FaBl93] [GrBl95] [CoTV93], 3D object recognition [LiFu86], visual programming environments [EgPM92], diagram editors [Gött92] [DoTo88], databases [EhKr80], and semantic networks [EhHK92]. Further discussion is given by [Panel91].) The fostering of a graph-rewriting culture will go far toward the popularization of graph rewr</context><context>iled into C. - A prototype implementation of algebraic graph transformation is described in [LöBe93]. At that time, the tool performed direct derivation steps in the singlepushout approach. - Göttler [Gött92] mentions a succession of implementations for executing ordered graph rewriting (Y and X notation); a new C implementation is under development, including a graphical editor for X notation rules. 5. M</context><context> nodes) to indicate the desired host graph location for rule application. Determinism is desirable in editing applications, where end-users expect a deterministic response to an editing command (e.g. [Gött92]). • Partially ordered rewrite systems, without backtracking, have been used for software engineering (e.g. [ELNSS92]) and diagram recognition (circuit-diagrams [Bunk82a], music-notation [FaBl93] [Fah</context><context>e legal at any given point. Events not foreseen by the control specification are disallowed, resulting in an error message to the user. A similar structure is used by the diagram editors described in [Gött92].s8 7. Mr. Maggraphen: How do we choose a graph-rewriting mechanism? A large variety of graph-rewriting mechanisms have been investigated. No one rewriting mechanism is universally suitable. Practical</context><context> part of g l (the &amp;quot;retraction&amp;quot;) Application Condition (the &amp;quot;guard&amp;quot;) Required Context Prohibited Context (the &amp;quot;restriction&amp;quot;) unique part of g r (the &amp;quot;insertion&amp;quot;) (a) Y notation [Gött83] (b) X notation [Gött92] (c) Δ notation [LoKa92] Figure 3 Three diagrammatic notations for graph-rewrite rules. In Y and X notations, the embedding is shown as optional context: these diagrammatic depictions of embedding are</context></contexts></citation><citation id="30119"><authors>D Harel</authors><title>On Visual Formalisms</title><venue>Communications of the ACM, Vol</venue><venType>JOURNAL</venType><year>1988</year><pages>514--530</pages><volume>31</volume><raw>D. Harel, “On Visual Formalisms,” Communications of the ACM, Vol 31, No 5, pp. 514-530, May 1988.</raw><contexts><context>des. The presence of such hierarchy-crossing edges greatly complicates the construction of tools for hierarchical graph rewriting. Various notations for hierarchical graph structures are described in [Hare88] [SiGJ93]. Hierarchical structure assists in the display of a large graph. Zoom-in and zoom-out operations reduce the graph to manageable proportions for viewing, or delimit selected portions of the g</context></contexts></citation><citation id="30120"><authors>T Henderson,A Samal</authors><title>Shape Grammar Compilers</title><venue>Pattern Recognition, Vol</venue><venType>JOURNAL</venType><year>1986</year><pages>279--288</pages><volume>19</volume><raw>T. Henderson and A. Samal, “Shape Grammar Compilers,” Pattern Recognition, Vol 19, No 4, pp. 279-288, 1986.</raw><contexts><context>it’s application to CAD/CAM [Klau94]. On a related note, Henderson and Samal discuss efficient parsing of stratified shape grammars, building on the tabledriven methods used for LR(k) string grammars [HeSa86]; these techniques might be relevant to graph-grammar parsing. Ordered graph rewriting For many computations it is convenient to order, or partially order, a collection of rewrite rules. For example, </context></contexts></citation><citation id="30121"><authors>M Himsolt</authors><title>GraphEd: An Interactive Tool for Developing Graph Grammars</title><raw>M. Himsolt, “GraphEd: An Interactive Tool for Developing Graph Grammars,” in</raw><contexts><context>gies if this list is incomplete. - PROGRES provides extensive facilities for ordered graph rewriting [NaSc91] [ELNSS92]. Contact andy@i3.informatik.rwth-aachen.de to obtain this software.s4 - GraphEd [Hims91] provides extensive graph-display capabilities, and supports a limited form of graph-rewriting (direct-derivation steps of context-free rewrite rules). Contact himsolt@fmi.uni-passau.de to obtain this</context></contexts></citation><citation id="30122"><authors>M Himsolt</authors><title>Hierarchical Graphs for Graph Grammars</title><venue>in [IWGG94</venue><venType>CONFERENCE</venType><pages>67--70</pages><raw>M. Himsolt, “Hierarchical Graphs for Graph Grammars,” in [IWGG94], pp. 67-70.</raw><contexts><context>graphs where node labels can be graphs themselves [Schn93]; flat host-graph structure with hierarchy-expressing rewriting rules used to zoom in and out [EhHK92] and to manage and display a derivation [Hims94]; use of hierarchical graphs in a formal approach to plan generation [ArJa94]; use of hierarchically distributed graph transformations [Taen94]. 2' A A 1' 3' B C B C Cs15 11. Mr. Maggraphen: A lot of </context></contexts></citation><citation id="30123"><authors>Workshop</authors><title>on Graph Grammars and Their Application to Computer Science and</title><venue>Biology, LNCS Vol</venue><venType>JOURNAL</venType><year>1979</year><volume>73</volume><raw>Intl. Workshop on Graph Grammars and Their Application to Computer Science and Biology, LNCS Vol . 73, V. Claus, H. Ehrig, G. Rozenberg Eds, Springer, 1979.</raw></citation><citation id="30124"><authors>Second Intl</authors><title>Workshop on Graph Grammars and Their Application to</title><venue>Computer Science, LNCS</venue><venType>JOURNAL</venType><year>1983</year><volume>153</volume><raw>Second Intl. Workshop on Graph Grammars and Their Application to Computer Science, LNCS Vol. 153, H. Ehrig, M. Nagl, G. Rozenberg Eds, Springer, 1983.</raw></citation><citation id="30125"><authors>Third Intl</authors><title>Workshop on Graph Grammars and Their Application to</title><venue>Computer Science, LNCS</venue><venType>JOURNAL</venType><year>1987</year><publisher>Eds, Springer</publisher><pubAddress>Ehrig, Nagl, Rozenberg, Rosenfeld</pubAddress><volume>291</volume><raw>Third Intl. Workshop on Graph Grammars and Their Application to Computer Science, LNCS Vol. 291, Ehrig, Nagl, Rozenberg, Rosenfeld Eds, Springer, 1987.</raw></citation><citation id="30126"><authors>Fourth Intl</authors><title>Workshop on Graph Grammars and Their Application to</title><venue>Computer Science, LNCS</venue><venType>JOURNAL</venType><year>1991</year><volume>532</volume><raw>Fourth Intl. Workshop on Graph Grammars and Their Application to Computer Science, LNCS Vol. 532, H. Ehrig, H. Kreowski, G. Rozenberg Eds, Springer, 1991.</raw></citation><citation id="30127"><title>Pre-proceedings of the Fifth Intl. Workshop on Graph Grammars and Their Application to Computer Science</title><year>1994</year><pubAddress>Williamsburg, VA</pubAddress><raw>Pre-proceedings of the Fifth Intl. Workshop on Graph Grammars and Their Application to Computer Science, Williamsburg, VA, Nov. 1994. Full versions of selected papers appear in this volume.</raw></citation><citation id="30128"><authors>M Kaul</authors><title>Parsing of Graphs</title><venue>in Linear Time,” in [IWGG83</venue><venType>CONFERENCE</venType><pages>206--218</pages><raw>M. Kaul, “Parsing of Graphs in Linear Time,” in [IWGG83], pp. 206-218.</raw><contexts><context>ed for certain restricted classes of graph grammars. A selection of parsing references are as follows. Kaul presents a linear-time precedence parser for a special class of context free graph-grammars [Kaul83]. Bunke and Haller describe an extension of Early’s parser for context-free plex languages [BuHa92]; this parser permits left-recursion and is capable of recognizing partial structures. Recently, a pa</context></contexts></citation><citation id="30129"><authors>C Klauck</authors><title>Heuristic Driven Chart-Parsing</title><venue>in [IWGG94</venue><venType>CONFERENCE</venType><pages>107--113</pages><raw>C. Klauck, “Heuristic Driven Chart-Parsing,” in [IWGG94], pp. 107-113.</raw><contexts><context>tom-up processing [CoTV93]. A chart-based parser for hierarchical graphs is discussed in [MaKl92]. More recently, Klauck reports on a heuristically-driven chart parser and it’s application to CAD/CAM [Klau94]. On a related note, Henderson and Samal discuss efficient parsing of stratified shape grammars, building on the tabledriven methods used for LR(k) string grammars [HeSa86]; these techniques might be </context></contexts></citation><citation id="30130"><authors>H-J Kreowski,G Rozenberg</authors><title>On Structured Graph Grammars</title><venue>I, II” Information Sciences</venue><venType>JOURNAL</venType><year>1990</year><pages>185--210</pages><volume>52</volume><raw>H.-J. Kreowski, G. Rozenberg, “On Structured Graph Grammars, I, II” Information Sciences, Vol. 52, 1990, pp. 185-210, 210-246.</raw><contexts><context>entified, rather than removing the g l host node and replacing it with the g r host node.) Such incomplete removal of non-induced subgraphs is provided in the definition of structured graph rewriting [KrRo90], and in the current PROGRES language [Schü91, p. 652]. (These semantics evolved over time: an earlier PROGRES reference describes the removal from host-graph of the complete subgraph corresponding to</context></contexts></citation><citation id="30131"><authors>W Lin,K S Fu</authors><title>A Syntactic Approach to Three-Dimensional Object Recognition</title><venue>IEEE Trans. Systems Man and Cybernetics</venue><venType>JOURNAL</venType><year>1986</year><pages>405--422</pages><volume>16</volume><raw>W. Lin and K.S. Fu, “A Syntactic Approach to Three-Dimensional Object Recognition,” IEEE Trans. Systems Man and Cybernetics, 16(3), May 1986, pp. 405-422.</raw><contexts><context>[BlFG95], include: software engineering [EnLS87] [ELNSS92] [LoKa92] [Pfei90], syntactic pattern recognition [Fu82], document image analysis [Bunk82a] [FaBl93] [GrBl95] [CoTV93], 3D object recognition [LiFu86], visual programming environments [EgPM92], diagram editors [Gött92] [DoTo88], databases [EhKr80], and semantic networks [EhHK92]. Further discussion is given by [Panel91].) The fostering of a graph-r</context><context>rogramming environment for clinical protocols [EgPM92]. Lin and Fu recognize three-dimensional objects (in two-dimensional images) using a semanticdirected top-down backtrack parser for plex grammars [LiFu86]. Collin et al. interpret dimensions in engineering drawings using a plex-grammar parser that mixes top-down and bottom-up processing [CoTV93]. A chart-based parser for hierarchical graphs is discusse</context></contexts></citation><citation id="30132"><authors>M Löwe,M Beyer</authors><title>AGG -- An Implementation of Algebraic Graph Rewriting</title><venue>Fifth Intl. Conf. on Rewriting Techniques and Applications</venue><venType>CONFERENCE</venType><year>1993</year><pages>451--456</pages><publisher>Springer</publisher><pubAddress>Montreal, Canada</pubAddress><raw>M. Löwe, M. Beyer, “AGG -- An Implementation of Algebraic Graph Rewriting,” Fifth Intl. Conf. on Rewriting Techniques and Applications, Montreal, Canada, June 1993, in LNCS 690, Springer, pp. 451-456.</raw><contexts><context>for algebraic graph rewriting [Pfei90]. In the meantime, a textual representation of a graph grammar is compiled into C. - A prototype implementation of algebraic graph transformation is described in [LöBe93]. At that time, the tool performed direct derivation steps in the singlepushout approach. - Göttler [Gött92] mentions a succession of implementations for executing ordered graph rewriting (Y and X not</context><context> interest in the topic of hierarchical graph rewriting. Relevant references include a chart-based parser for hierarchical-graphs [MaKl92]; abstract graphs in a prototype algebraic-rewrite environment [LöBe93]; graphs where node labels can be graphs themselves [Schn93]; flat host-graph structure with hierarchy-expressing rewriting rules used to zoom in and out [EhHK92] and to manage and display a derivatio</context></contexts></citation><citation id="30133"><authors>J Loyall,S Kaplan</authors><title>Visual Concurrent Programming with Delta-Grammars</title><venue>Journal of Visual Languages and Computing, Vol</venue><venType>JOURNAL</venType><year>1992</year><pages>107--133</pages><volume>3</volume><raw>J. Loyall and S. Kaplan, “Visual Concurrent Programming with Delta-Grammars,” Journal of Visual Languages and Computing, Vol 3, 1992, pp. 107-133.</raw><contexts><context>ems are most helpful. These illustrate various computational styles in which graph rewriting may be used. (Relevant references, discussed in [BlFG95], include: software engineering [EnLS87] [ELNSS92] [LoKa92] [Pfei90], syntactic pattern recognition [Fu82], document image analysis [Bunk82a] [FaBl93] [GrBl95] [CoTV93], 3D object recognition [LiFu86], visual programming environments [EgPM92], diagram editors</context><context> [ZüSc92]). We now briefly review the practical use of these four system organizations. Unordered graph rewriting An excellent example of unordered graph rewriting is provided by Δ-rewriting [KaLG91] [LoKa92]. The rewriting system is given an initial host-graph (e.g. the quicksort example of [LoKa92, p. 177] uses a list of numbers to be sorted, the specification of the Actor language of [KaLG91, p. 484] u</context><context>ction&amp;quot;) Application Condition (the &amp;quot;guard&amp;quot;) Required Context Prohibited Context (the &amp;quot;restriction&amp;quot;) unique part of g r (the &amp;quot;insertion&amp;quot;) (a) Y notation [Gött83] (b) X notation [Gött92] (c) Δ notation [LoKa92] Figure 3 Three diagrammatic notations for graph-rewrite rules. In Y and X notations, the embedding is shown as optional context: these diagrammatic depictions of embedding are used if they match in t</context><context> Δ-rewriting uses subgraph isomorphism, but with a label-subscript notation (called a fold) to explicitly indicate groups of nodes which can optionally be matched to a single host-graph node [KaLG91] [LoKa92]. The utility of this construct is demonstrated by a rule to insert an element into a circular list: one rule works for circular lists of any length ≥ 1. Extensions to the Rewrite Mechanism Many exten</context><context>med by a set of graph-rewrite rules, with no control specification). To allow the designer to divide a large problem into more manageable subproblems, Δ-rewrite systems use platforms of related rules [LoKa92] [ToKa94]. These platforms are defined via specially labeled nodes called trigger nodes. To define a platform, choose a new trigger label. Every rewrite rule in the platform contains this trigger node</context></contexts></citation><citation id="30134"><authors>J Mauss,C Klauck</authors><title>A Heuristic Driven Parser Based on Graph Grammars for Feature Recognition</title><venue>in CIM,” Advances in Structural and Syntactic Pattern Recognition</venue><venType>CONFERENCE</venType><year>1992</year><pages>611--620</pages><raw>J. Mauss and C. Klauck, “A Heuristic Driven Parser Based on Graph Grammars for Feature Recognition in CIM,” Advances in Structural and Syntactic Pattern Recognition, Ed. H. Bunke, World Scientific, 1992, pp. 611-620.</raw><contexts><context>t give many special considerations to these edges. There is significant interest in the topic of hierarchical graph rewriting. Relevant references include a chart-based parser for hierarchical-graphs [MaKl92]; abstract graphs in a prototype algebraic-rewrite environment [LöBe93]; graphs where node labels can be graphs themselves [Schn93]; flat host-graph structure with hierarchy-expressing rewriting rules</context></contexts></citation><citation id="30135"><authors>M Nagl,A Schürr</authors><title>A Specification Environment for Graph Grammars</title><raw>M. Nagl, A. Schürr, “A Specification Environment for Graph Grammars,” in</raw><contexts><context>ive further development. The remaining environments may become available for general use. Our apologies if this list is incomplete. - PROGRES provides extensive facilities for ordered graph rewriting [NaSc91] [ELNSS92]. Contact andy@i3.informatik.rwth-aachen.de to obtain this software.s4 - GraphEd [Hims91] provides extensive graph-display capabilities, and supports a limited form of graph-rewriting (direc</context><context>an be used to compute values for derived attributes. The applicability of a rewrite rule (or a subprogram of rules) can be tested without executing it. Global on-going graph inspection is proposed in [NaSc91]: global runtime conditions are used to state hostgraph conditions that should always (or never) hold. In summary, practically-usable graph rewriting languages must provide general facilities for grap</context></contexts></citation><citation id="30136"><title>Panel Discussion: The Use of Graph Grammars</title><venue>in Applications,” in [IWGG91</venue><venType>CONFERENCE</venType><pages>41--60</pages><raw>“Panel Discussion: The Use of Graph Grammars in Applications,” in [IWGG91], pp. 41-60.</raw><contexts><context>oTV93], 3D object recognition [LiFu86], visual programming environments [EgPM92], diagram editors [Gött92] [DoTo88], databases [EhKr80], and semantic networks [EhHK92]. Further discussion is given by [Panel91].) The fostering of a graph-rewriting culture will go far toward the popularization of graph rewriting. 3. Mr. Maggraphen: In C, we use standard algorithms (searching, sorting, hashing) and algorithm-</context></contexts></citation><citation id="30137"><authors>J Pfeiffer</authors><title>Using Graph Grammars for Data Structure Manipulation</title><venue>Proc. 1990 IEEE Workshop on Visual Languages</venue><venType>CONFERENCE</venType><pages>42--47</pages><raw>J. Pfeiffer, “Using Graph Grammars for Data Structure Manipulation,” Proc. 1990 IEEE Workshop on Visual Languages, pp. 42-47.</raw><contexts><context>ost helpful. These illustrate various computational styles in which graph rewriting may be used. (Relevant references, discussed in [BlFG95], include: software engineering [EnLS87] [ELNSS92] [LoKa92] [Pfei90], syntactic pattern recognition [Fu82], document image analysis [Bunk82a] [FaBl93] [GrBl95] [CoTV93], 3D object recognition [LiFu86], visual programming environments [EgPM92], diagram editors [Gött92]</context><context>eps of context-free rewrite rules). Contact himsolt@fmi.uni-passau.de to obtain this software. - Pfeiffer describes development plans for a graphical editing environment for algebraic graph rewriting [Pfei90]. In the meantime, a textual representation of a graph grammar is compiled into C. - A prototype implementation of algebraic graph transformation is described in [LöBe93]. At that time, the tool perfo</context></contexts></citation><citation id="30138"><authors>J Rekers,A Schürr</authors><title>Parsing for Context-Sensitive Graph Grammars</title><raw>J. Rekers and A. Schürr, “Parsing for Context-Sensitive Graph Grammars,” in</raw><contexts><context>anguages [BuHa92]; this parser permits left-recursion and is capable of recognizing partial structures. Recently, a parsing algorithm applicable to context-sensitive graph grammars has been developed [ReSc94]. Egar et al. use a graph-grammar parser in the design of a visual programming environment for clinical protocols [EgPM92]. Lin and Fu recognize three-dimensional objects (in two-dimensional images) u</context></contexts></citation><citation id="30139"><authors>G Rozenberg</authors><title>An Introduction to the NLC Way of Rewriting Graphs</title><raw>G. Rozenberg, &amp;quot;An Introduction to the NLC Way of Rewriting Graphs,&amp;quot; in</raw><contexts><context>is found and replaced, resulting in the new host graph (c). (We use the standard removal and replacement of g l host , as in the LEARRE steps: Locate, establish Embedding Area, Remove, Replace, Embed [Roze87].) Note the implicit edge-deletion in (c): the edge from the C-labeled node to the B-labeled node is removed in host-graph, an effect that may or may not have been anticipated by the author of rewrite</context></contexts></citation><citation id="30140"><authors>A Schürr</authors><title>PROGRESS: A VHL-Language Based on Graph Grammars</title><raw>A. Schürr, “PROGRESS: A VHL-Language Based on Graph Grammars,&amp;quot; in</raw></citation><citation id="30141"><authors>H Schneider</authors><title>On categorical graph grammars integrating structural transformations and operations on labels</title><venue>Theoretical Computer Science</venue><venType>JOURNAL</venType><year>1993</year><pages>257--275</pages><volume>109</volume><raw>H. Schneider, “On categorical graph grammars integrating structural transformations and operations on labels,” Theoretical Computer Science, Vol. 109, 1993, pp. 257-275.</raw><contexts><context>vant references include a chart-based parser for hierarchical-graphs [MaKl92]; abstract graphs in a prototype algebraic-rewrite environment [LöBe93]; graphs where node labels can be graphs themselves [Schn93]; flat host-graph structure with hierarchy-expressing rewriting rules used to zoom in and out [EhHK92] and to manage and display a derivation [Hims94]; use of hierarchical graphs in a formal approach </context></contexts></citation><citation id="30142"><authors>G Sindre,B Gulla,H Jokstad</authors><title>Onion Graphs: Aesthetics and Layout</title><venue>Proc. 1993 IEEE Symposium on Visual Languages</venue><venType>CONFERENCE</venType><year>1993</year><pages>287--291</pages><pubAddress>Bergen, Norway</pubAddress><raw>G. Sindre, B. Gulla, H. Jokstad, “Onion Graphs: Aesthetics and Layout,” Proc. 1993 IEEE Symposium on Visual Languages, Bergen, Norway, Aug. 1993, pp. 287-291.</raw><contexts><context>ile data representation. Typically, nodes represent objects or concepts, and edges represent relationships among them. In addition, hierarchical relationships can be depicted by node-nesting [Hare88] [SiGJ93]. Auxiliary information is expressed by adding attributes to nodes or edges. Given the widespread use of graphs as a data representation, it is natural that graph manipulations form the basis of many </context><context>presence of such hierarchy-crossing edges greatly complicates the construction of tools for hierarchical graph rewriting. Various notations for hierarchical graph structures are described in [Hare88] [SiGJ93]. Hierarchical structure assists in the display of a large graph. Zoom-in and zoom-out operations reduce the graph to manageable proportions for viewing, or delimit selected portions of the graph for </context></contexts></citation><citation id="30143"><authors>T Strzalkowski</authors><title>Reversible Logic Grammars for Natural Language Parsing and Generation</title><venue>Canadian Computational Intelligence Journal</venue><venType>JOURNAL</venType><year>1990</year><pages>145--171</pages><volume>6</volume><raw>T. Strzalkowski, “Reversible Logic Grammars for Natural Language Parsing and Generation,” Canadian Computational Intelligence Journal, 6(3), pp. 145-171, 1990.</raw><contexts><context>computations are common. Reversibility is desired in various domains, but difficult to achieve. For example, there is on-going research into reversible string-grammars for natural language processing [Strz90]. On a related note, a graph grammar with nonreversible rules is limited to either bottom-up or top-down parsers. Practical use of graph grammars is seriously hampered by the high complexity of parsin</context></contexts></citation><citation id="30144"><authors>G Taentzer</authors><title>Hierarchically Distributed Graph Transformations,” in [IWGG94</title><venue>in [IWGG94</venue><venType>CONFERENCE</venType><year>1992</year><pages>430--435</pages><publisher>Springer Verlag</publisher><raw>G. Taentzer, “Hierarchically Distributed Graph Transformations,” in [IWGG94], pp. 430-435.[ToKa94] W. Tolone and S. Kaplan, “A Semantic Definition for Introspect using Δ-Grammars,” in [IWGG94], pp. 418-423.[ZüSc92] A. Zündorf and A. Schürr, “Nondeterministic Control Structures for Graph Rewriting Systems,” Proc 17th Intl. Workshop on Graph-Theoretic Concepts in Computer Science WG91, LNCS Vol 570, Springer Verlag, 1992.</raw><contexts><context>ions can be modularized, with some modules transforming local graphs, others changing interfaces or the global graph, and yet others changing the graph hierarchy (split or join local graphs) [EhEn94] [Taen94]. Inheritance Inheritance is a powerful tool for layering in object-oriented system design. Several forms of inheritance can be used within a graph-rewriting system; some examples are mentioned earlie</context><context> and out [EhHK92] and to manage and display a derivation [Hims94]; use of hierarchical graphs in a formal approach to plan generation [ArJa94]; use of hierarchically distributed graph transformations [Taen94]. 2' A A 1' 3' B C B C Cs15 11. Mr. Maggraphen: A lot of our C code performs graph inspections. How can we translate this into graph-rewrite rules? The Maggraphens’ current software freely mixes graph</context></contexts></citation></citations><fileInfo><url>http://www.cs.queensu.ca/home/blostein/LNCS1073.pdf</url><repID>rep1</repID><conversionTrace>PDFLib TET</conversionTrace><checkSums><checkSum><fileType>pdf</fileType><sha1>9afafdeacb5a1a382cbd2640f91d18d27f100de8</sha1></checkSum></checkSums></fileInfo></document>