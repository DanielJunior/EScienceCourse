<document id="10.1.1.1.1542"><title src="SVM HeaderParse 0.1">PROTOTYPING PROOF CARRYING CODE</title><abstract src="SVM HeaderParse 0.1">Abstract We introduce a generic framework for proof carrying code, developed and mechanically verified in Isabelle/HOL. The framework defines and proves sound a verification condition generator with minimal assumptions on the underlying programming language, safety policy, and safety logic. We demonstrate its usability for prototyping proof carrying code systems by instantiating it to a simple assembly language with procedures and a safety policy for arithmetic overflow. 1</abstract><keywords></keywords><authors><author id="4301"><name src="SVM HeaderParse 0.1">Martin Wildmoser</name><email src="SVM HeaderParse 0.1">wildmosm@in.tum.de</email><order>1</order></author><author id="4302"><name src="SVM HeaderParse 0.1">Tobias Nipkow</name><email src="SVM HeaderParse 0.1">nipkow@in.tum.de</email><order>2</order></author><author id="4303"><name src="SVM HeaderParse 0.1">Gerwin Klein</name><email src="SVM HeaderParse 0.1">gerwin.klein@nicta.com.au</email><order>3</order></author><author id="4304"><name src="SVM HeaderParse 0.1">Sebastian Nanz</name><email src="SVM HeaderParse 0.1">nanz@cs.yale.edu</email><order>4</order></author></authors><citations src="ParsCit 1.0"><citation id="28893"><authors>A W Appel</authors><title>Foundational proof-carrying code</title><venue>In 16th Annual IEEE Symposium on Logic in Computer Science (LICS</venue><venType>CONFERENCE</venType><year>2001</year><pages>247--258</pages><volume>01</volume><raw>Appel, A. W. (2001). Foundational proof-carrying code. In 16th Annual IEEE Symposium on Logic in Computer Science (LICS ’01), pages 247–258.</raw><contexts><context>rm for trying out, tuning, and analysing different safety policies and logics for different target platforms. Our approach is different from other work in the formal foundation of PCC by Appel et al. [1] [2] or Hamid et al. [7] in that it works with an explicit, executable, and verified VCG and not directly on the machine semantics or a type system. The focus of the framework is on aiding logical fou</context></contexts></citation><citation id="28894"><authors>A W Appel,A P Felty</authors><title>A semantic model of types and machine instructions for proof-carrying code</title><venue>In 27th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL ’00</venue><venType>CONFERENCE</venType><year>2000</year><pages>243--253</pages><raw>Appel, A. W. and Felty, A. P. (2000). A semantic model of types and machine instructions for proof-carrying code. In 27th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL ’00), pages 243–253.</raw><contexts><context>or trying out, tuning, and analysing different safety policies and logics for different target platforms. Our approach is different from other work in the formal foundation of PCC by Appel et al. [1] [2] or Hamid et al. [7] in that it works with an explicit, executable, and verified VCG and not directly on the machine semantics or a type system. The focus of the framework is on aiding logical foundat</context></contexts></citation><citation id="28895"><authors>D Aspinall,L Beringer,M Hofmann,H W Loidl</authors><title>A Resource-aware Program Logic for a JVM-like Language</title><venue>In Trends in Functional Programming</venue><venType>CONFERENCE</venType><year>2003</year><editors>editor: S. Gilmore, Edinburgh</editors><raw>Aspinall, D., Beringer, L., Hofmann, M., Loidl, H.W. (2003) A Resource-aware Program Logic for a JVM-like Language In Trends in Functional Programming, editor: S. Gilmore, Edinburgh</raw><contexts><context>d to that sound core. On a broader scale, our approach is related to other techniques that impose safety policies on machine code statically: Typed Assembly Language [10], Mobile Ressource Guarantees [3] or Java Bytecode Verification [8]. There are four levels in our PCC systems. The first level, the PCC framework (§2), provides generic features and minimal assumptions. The second level is the platfo</context></contexts></citation><citation id="28896"><authors>S Berghofer,T Nipkow</authors><title>Proof terms for simply typed higher order logic</title><venue>In Theorem Proving in Higher Order Logics, Springer LNCS</venue><venType>CONFERENCE</venType><year>2000</year><editors>vol. 1869, editors: J. Harrison, M. Aagaard</editors><raw>Berghofer, S. and Nipkow, T. (2000). Proof terms for simply typed higher order logic. In Theorem Proving in Higher Order Logics, Springer LNCS vol. 1869, editors: J. Harrison, M. Aagaard</raw><contexts><context>ig. 6 the simplifier and a decision procedure for presburger arithmetic suffice to prove the verification condition. For the client side Isabelle provides (compressed) proof terms and a proof checker [4]. Proofs are encoded as λ terms having a type that corresponds to the theorem they prove (Curry Howard Isomorphism). Proof Checking becomes a type checking problem, which can be handled by a small tru</context></contexts></citation><citation id="28897"><authors>Berghofer</authors><title>Program Extraction in simply-typed Higher Order Logic</title><venue>In Types for Proofs and Programs, International Workshop, (TYPES 2002</venue><venType>CONFERENCE</venType><year>2003</year><editors>LNCS, editors: H. Geuvers, F. Wiedijk</editors><publisher>Springer</publisher><raw>Berghofer (2003). Program Extraction in simply-typed Higher Order Logic. In Types for Proofs and Programs, International Workshop, (TYPES 2002), Springer LNCS, editors: H. Geuvers, F. Wiedijk</raw><contexts><context> form isafeF OD (0,2). 4.4 Code Producer and Consumer The code producer can write annotated programs in Isabelle. To obtain the verification condition one can generate and execute ML code for the VCG [5] or use the simplifiers12 to evaluate vcg Π. Proving the verification condition is supported by powerful proof tools and a rich collection of HOL theorems. For the example in Fig. 6 the simplifier and</context></contexts></citation><citation id="28898"><authors>C Colby,P Lee,G C Necula,F Blau,M Plesko,K Cline</authors><title>A certifying compiler for Java</title><venue>In Proc. ACM SIGPLAN conf. Programming Language Design and Implementation</venue><venType>CONFERENCE</venType><year>2000</year><pages>95--107</pages><raw>Colby, C., Lee, P., Necula, G. C., Blau, F., Plesko, M., and Cline, K. (2000). A certifying compiler for Java. In Proc. ACM SIGPLAN conf. Programming Language Design and Implementation, pages 95–107.</raw><contexts><context>base of the PCC system. Proof checkers are relatively small standard components of many logical frameworks. The VCG on the other hand is large (several thousand lines of C code in current PCC systems [6] [13]) and complex (it handles annotations, produces complex formulae, and contains parts of the safety policy). Our framework contains a VCG with a formal proof of safety, mechanically checked in the</context><context>particular machine language, safety policy, or safety logic. Additionally to the correctness of VCG and proof checker, we need the safety logic to be sound. As a recent bug [9] in the SpecialJ system [6] shows, this is not trivial. It is not even immediately clear, what exactly a safety logic must satisfy to be sound. Our framework makes the underlying assumptions on machine, policy, and logic explic</context></contexts></citation><citation id="28899"><authors>N Hamid,Z Shao,V Trifonov,S Monnier,Z Ni</authors><title>A syntactic approach to foundational proof-carrying code</title><venue>In Proc. 17th IEEE Symp. Logic in Computer Science</venue><venType>CONFERENCE</venType><year>2002</year><pages>89--100</pages><raw>Hamid, N., Shao, Z., Trifonov, V., Monnier, S., and Ni, Z. (2002). A syntactic approach to foundational proof-carrying code. In Proc. 17th IEEE Symp. Logic in Computer Science, pages 89–100.</raw><contexts><context>g, and analysing different safety policies and logics for different target platforms. Our approach is different from other work in the formal foundation of PCC by Appel et al. [1] [2] or Hamid et al. [7] in that it works with an explicit, executable, and verified VCG and not directly on the machine semantics or a type system. The focus of the framework is on aiding logical foundations of PCC as the o</context></contexts></citation><citation id="28900"><authors>G Klein</authors><title>Verified Java Bytecode Verification</title><venType>TECHREPORT</venType><year>2003</year><tech>PhD thesis</tech><raw>Klein, G. (2003). Verified Java Bytecode Verification. PhD thesis, Institut für Informatik, Technische Universität München.</raw><contexts><context> scale, our approach is related to other techniques that impose safety policies on machine code statically: Typed Assembly Language [10], Mobile Ressource Guarantees [3] or Java Bytecode Verification [8]. There are four levels in our PCC systems. The first level, the PCC framework (§2), provides generic features and minimal assumptions. The second level is the platform (§3). Platform designers can pr</context></contexts></citation><citation id="28901"><authors>C League,Z Shao,V Trifonov</authors><title>Precision in practice: A type-preserving Java compiler</title><venType>TECHREPORT</venType><year>2002</year><tech>Technical Report YALEU/DCS/TR-1223</tech><raw>League, C., Shao, Z., and Trifonov, V. (2002). Precision in practice: A type-preserving Java compiler. Technical Report YALEU/DCS/TR-1223, Department of Computer Science, Yale University.</raw><contexts><context>G is not restricted to any particular machine language, safety policy, or safety logic. Additionally to the correctness of VCG and proof checker, we need the safety logic to be sound. As a recent bug [9] in the SpecialJ system [6] shows, this is not trivial. It is not even immediately clear, what exactly a safety logic must satisfy to be sound. Our framework makes the underlying assumptions on machin</context></contexts></citation><citation id="28902"><authors>G Morrisett,D Walker,K Crary,N Glew</authors><title>From system F to typed assembly language</title><venue>In Proc. 25th ACM Symp. Principles of Programming Languages</venue><venType>CONFERENCE</venType><year>1998</year><pages>85--97</pages><publisher>ACM Press</publisher><raw>Morrisett, G., Walker, D., Crary, K., and Glew, N. (1998). From system F to typed assembly language. In Proc. 25th ACM Symp. Principles of Programming Languages, pages 85–97. ACM Press.</raw><contexts><context>ised extensions can then be applied to that sound core. On a broader scale, our approach is related to other techniques that impose safety policies on machine code statically: Typed Assembly Language [10], Mobile Ressource Guarantees [3] or Java Bytecode Verification [8]. There are four levels in our PCC systems. The first level, the PCC framework (§2), provides generic features and minimal assumption</context></contexts></citation><citation id="28903"><authors>G C Necula</authors><title>Proof-carrying code</title><venue>In Proc. 24th ACM Symp. Principles of Programming Languages</venue><venType>CONFERENCE</venType><year>1997</year><pages>106--119</pages><publisher>ACM Press</publisher><raw>Necula, G. C. (1997). Proof-carrying code. In Proc. 24th ACM Symp. Principles of Programming Languages, pages 106–119. ACM Press.</raw><contexts><context> code systems by instantiating it to a simple assembly language with procedures and a safety policy for arithmetic overflow. 1 Introduction Proof Carrying Code (PCC), first proposed by Necula and Lee [11] [12], is a scheme for executing untrusted code safely. Fig. 1 shows the architecture of a PCC system. The code producer is on the left, the code receiver on the right. Both use a verification conditi</context></contexts></citation><citation id="28904"><authors>G C Necula</authors><title>Compiling with Proofs</title><venType>TECHREPORT</venType><year>1998</year><tech>PhD thesis</tech><raw>Necula, G. C. (1998). Compiling with Proofs. PhD thesis, Carnegie Mellon University.</raw><contexts><context> systems by instantiating it to a simple assembly language with procedures and a safety policy for arithmetic overflow. 1 Introduction Proof Carrying Code (PCC), first proposed by Necula and Lee [11] [12], is a scheme for executing untrusted code safely. Fig. 1 shows the architecture of a PCC system. The code producer is on the left, the code receiver on the right. Both use a verification condition ge</context></contexts></citation><citation id="28905"><authors>G C Necula,P Lee</authors><title>Proof generation in the touchstone theorem prover</title><venue>Automated Deduction — CADE-17, volume 1831 of Lect. Notes in Comp. Sci</venue><venType>CONFERENCE</venType><year>2000</year><pages>25--44</pages><editors>In McAllester, D., editor</editors><publisher>Springer-Verlag</publisher><raw>Necula, G. C. and Lee, P. (2000). Proof generation in the touchstone theorem prover. In McAllester, D., editor, Automated Deduction — CADE-17, volume 1831 of Lect. Notes in Comp. Sci., pages 25–44. Springer-Verlag.</raw><contexts><context> of the PCC system. Proof checkers are relatively small standard components of many logical frameworks. The VCG on the other hand is large (several thousand lines of C code in current PCC systems [6] [13]) and complex (it handles annotations, produces complex formulae, and contains parts of the safety policy). Our framework contains a VCG with a formal proof of safety, mechanically checked in the theo</context></contexts></citation><citation id="28906"><authors>G C Necula,R R Schneck</authors><title>A gradual approach to a more trustworthy, yet scalable, proof-carrying code</title><venue>Proc.CADE-18, 18th International Conference on Automated Deduction</venue><venType>CONFERENCE</venType><year>2002</year><pages>47--62</pages><editors>In Voronkov, A., editor</editors><publisher>Springer-Verlag</publisher><pubAddress>Copenhagen, Denmark</pubAddress><volume>2392</volume><raw>Necula, G. C. and Schneck, R. R. (2002). A gradual approach to a more trustworthy, yet scalable, proof-carrying code. In Voronkov, A., editor, Proc.CADE-18, 18th International Conference on Automated Deduction, Copenhagen, Denmark, volume 2392 of Lect. Notes in Comp. Sci., pages 47–62. Springer-Verlag.</raw><contexts><context>t, executable, and verified VCG and not directly on the machine semantics or a type system. The focus of the framework is on aiding logical foundations of PCC as the one started by Necula and Schneck [14] and on encouraging the analysis of safety properties other than the much researched type and memory safety. Necula and Schneck [15] also present a framework for VCGs. They work with a small, trusted </context></contexts></citation><citation id="28907"><authors>G C Necula,R R Schneck</authors><title>A sound framework for untrustred verificationcondition generators</title><venue>In Proc. IEEE Symposium on Logic in Computer Science (LICS03</venue><venType>CONFERENCE</venType><year>2003</year><pages>248--260</pages><raw>Necula, G. C. and Schneck, R. R. (2003). A sound framework for untrustred verificationcondition generators. In Proc. IEEE Symposium on Logic in Computer Science (LICS03), pages 248–260.</raw><contexts><context>logical foundations of PCC as the one started by Necula and Schneck [14] and on encouraging the analysis of safety properties other than the much researched type and memory safety. Necula and Schneck [15] also present a framework for VCGs. They work with a small, trusted core VCG that can be extended by optimised plugins. We see our work as complementary to this development: the core VCG could be prov</context></contexts></citation><citation id="28908"><authors>T Nipkow,L C Paulson,M Wenzel</authors><title>Isabelle/HOL – A Proof Assistant for Higher-Order Logic, volume 2283</title><venue>of Lect. Notes in Comp. Sci</venue><venType>CONFERENCE</venType><year>2002</year><publisher>Springer</publisher><raw>Nipkow, T., Paulson, L. C., and Wenzel, M. (2002). Isabelle/HOL – A Proof Assistant for Higher-Order Logic, volume 2283 of Lect. Notes in Comp. Sci. Springer.</raw><contexts><context>s annotations, produces complex formulae, and contains parts of the safety policy). Our framework contains a VCG with a formal proof of safety, mechanically checked in the theorem prover Isabelle/HOL [16]. The VCG is not restricted to any particular machine language, safety policy, or safety logic. Additionally to the correctness of VCG and proof checker, we need the safety logic to be sound. As a rec</context></contexts></citation><citation id="28909"><authors>G Klein,T Nipkow</authors><title>A Machine-Checked Model for a Java-Like Language</title><venue>Virtual Machine and Compiler Technical Report, National ICT</venue><venType>CONFERENCE</venType><year>2004</year><pubAddress>Australia, Sydney</pubAddress><raw>Klein, G. and Nipkow, T. (2004) A Machine-Checked Model for a Java-Like Language, Virtual Machine and Compiler Technical Report, National ICT Australia, Sydney</raw><contexts><context>unctions. This enables us to optimise verification conditions after/during their construction. By now, we also have instantiated the PCC framework to a (downsized) version of the Java Virtual Machine [17]. For this we did not have to change the framework, thus we believe that our framework’s formalisation and its requirements are reasonable, even for real life platforms.sPrototyping Proof Carrying Cod</context></contexts></citation><citation id="28910"><authors>M Wildmoser,T Nipkow</authors><title>Certifying machine code safety: shallow versus deep embedding. TPHOLs 2004</title><year>2004</year><raw>Wildmoser, M. and Nipkow, T. (2004) Certifying machine code safety: shallow versus deep embedding. TPHOLs 2004</raw><contexts><context>tic or recursive procedures and safety policies about time and memory consumption of programs. Moreover we have instantiated a safety logic based on first order arithmetic in form of a deep embedding [18]. There, formulae are modelled as HOL datatype and can by analysed by other HOL functions. This enables us to optimise verification conditions after/during their construction. By now, we also have ins</context></contexts></citation></citations><fileInfo><url>http://www.doc.ic.ac.uk/~nanz/publications/./ppcc_tcs04.pdf</url><repID>rep1</repID><conversionTrace>PDFLib TET</conversionTrace><checkSums><checkSum><fileType>pdf</fileType><sha1>1dc22468e2f8c8dfaece05c85f06f5a61f4083c1</sha1></checkSum></checkSums></fileInfo></document>